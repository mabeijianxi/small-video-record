@c DO NOT EDIT THIS FILE!
@c It was generated by print_options.

@section Codec AVOptions
@table @option
@item -b[:stream_specifier] @var{integer} (@emph{output,audio,video})
set bitrate (in bits/s)
@item -ab[:stream_specifier] @var{integer} (@emph{output,audio})
set bitrate (in bits/s)
@item -bt[:stream_specifier] @var{integer} (@emph{output,video})
Set video bitrate tolerance (in bits/s). In 1-pass mode, bitrate tolerance specifies how far ratecontrol is willing to deviate from the target average bitrate value. This is not related to minimum/maximum bitrate. Lowering tolerance too much has an adverse effect on quality.
@item -flags[:stream_specifier] @var{flags} (@emph{input/output,audio,video,subtitles})

Possible values:
@table @samp
@item unaligned
allow decoders to produce unaligned output
@item mv4
use four motion vectors per macroblock (MPEG-4)
@item qpel
use 1/4-pel motion compensation
@item loop
use loop filter
@item qscale
use fixed qscale
@item gmc
use gmc
@item mv0
always try a mb with mv=<0,0>
@item input_preserved

@item pass1
use internal 2-pass ratecontrol in first  pass mode
@item pass2
use internal 2-pass ratecontrol in second pass mode
@item gray
only decode/encode grayscale
@item emu_edge
do not draw edges
@item psnr
error[?] variables will be set during encoding
@item truncated
Input bitstream might be randomly truncated
@item naq
normalize adaptive quantization
@item ildct
use interlaced DCT
@item low_delay
force low delay
@item global_header
place global headers in extradata instead of every keyframe
@item bitexact
use only bitexact functions (except (I)DCT)
@item aic
H.263 advanced intra coding / MPEG-4 AC prediction
@item ilme
interlaced motion estimation
@item cgop
closed GOP
@item output_corrupt
Output even potentially corrupted frames
@end table
@item -me_method[:stream_specifier] @var{integer} (@emph{output,video})
set motion estimation method

Possible values:
@table @samp
@item zero
zero motion estimation (fastest)
@item full
full motion estimation (slowest)
@item epzs
EPZS motion estimation
@item esa
esa motion estimation (alias for full)
@item tesa
tesa motion estimation
@item dia
diamond motion estimation (alias for EPZS)
@item log
log motion estimation
@item phods
phods motion estimation
@item x1
X1 motion estimation
@item hex
hex motion estimation
@item umh
umh motion estimation
@item iter
iter motion estimation
@end table
@item -g[:stream_specifier] @var{integer} (@emph{output,video})
set the group of picture (GOP) size
@item -ar[:stream_specifier] @var{integer} (@emph{input/output,audio})
set audio sampling rate (in Hz)
@item -ac[:stream_specifier] @var{integer} (@emph{input/output,audio})
set number of audio channels
@item -cutoff[:stream_specifier] @var{integer} (@emph{output,audio})
set cutoff bandwidth
@item -frame_size[:stream_specifier] @var{integer} (@emph{output,audio})
@item -qcomp[:stream_specifier] @var{float} (@emph{output,video})
video quantizer scale compression (VBR). Constant of ratecontrol equation. Recommended range for default rc_eq: 0.0-1.0
@item -qblur[:stream_specifier] @var{float} (@emph{output,video})
video quantizer scale blur (VBR)
@item -qmin[:stream_specifier] @var{integer} (@emph{output,video})
minimum video quantizer scale (VBR)
@item -qmax[:stream_specifier] @var{integer} (@emph{output,video})
maximum video quantizer scale (VBR)
@item -qdiff[:stream_specifier] @var{integer} (@emph{output,video})
maximum difference between the quantizer scales (VBR)
@item -bf[:stream_specifier] @var{integer} (@emph{output,video})
set maximum number of B-frames between non-B-frames
@item -b_qfactor[:stream_specifier] @var{float} (@emph{output,video})
QP factor between P- and B-frames
@item -rc_strategy[:stream_specifier] @var{integer} (@emph{output,video})
ratecontrol method
@item -b_strategy[:stream_specifier] @var{integer} (@emph{output,video})
strategy to choose between I/P/B-frames
@item -ps[:stream_specifier] @var{integer} (@emph{output,video})
RTP payload size in bytes
@item -bug[:stream_specifier] @var{flags} (@emph{input,video})
work around not autodetected encoder bugs

Possible values:
@table @samp
@item autodetect

@item old_msmpeg4
some old lavc-generated MSMPEG4v3 files (no autodetection)
@item xvid_ilace
Xvid interlacing bug (autodetected if FOURCC == XVIX)
@item ump4
(autodetected if FOURCC == UMP4)
@item no_padding
padding bug (autodetected)
@item amv

@item ac_vlc
illegal VLC bug (autodetected per FOURCC)
@item qpel_chroma

@item std_qpel
old standard qpel (autodetected per FOURCC/version)
@item qpel_chroma2

@item direct_blocksize
direct-qpel-blocksize bug (autodetected per FOURCC/version)
@item edge
edge padding bug (autodetected per FOURCC/version)
@item hpel_chroma

@item dc_clip

@item ms
work around various bugs in Microsoft's broken decoders
@item trunc
truncated frames
@item iedge

@end table
@item -strict[:stream_specifier] @var{integer} (@emph{input/output,audio,video})
how strictly to follow the standards

Possible values:
@table @samp
@item very
strictly conform to a older more strict version of the spec or reference software
@item strict
strictly conform to all the things in the spec no matter what the consequences
@item normal

@item unofficial
allow unofficial extensions
@item experimental
allow non-standardized experimental things
@end table
@item -b_qoffset[:stream_specifier] @var{float} (@emph{output,video})
QP offset between P- and B-frames
@item -err_detect[:stream_specifier] @var{flags} (@emph{input,audio,video})
set error detection flags

Possible values:
@table @samp
@item crccheck
verify embedded CRCs
@item bitstream
detect bitstream specification deviations
@item buffer
detect improper bitstream length
@item explode
abort decoding on minor error detection
@item ignore_err
ignore errors
@item careful
consider things that violate the spec, are fast to check and have not been seen in the wild as errors
@item compliant
consider all spec non compliancies as errors
@item aggressive
consider things that a sane encoder should not do as an error
@end table
@item -mpeg_quant[:stream_specifier] @var{integer} (@emph{output,video})
use MPEG quantizers instead of H.263
@item -qsquish[:stream_specifier] @var{float} (@emph{output,video})
deprecated, use encoder private options instead
@item -rc_qmod_amp[:stream_specifier] @var{float} (@emph{output,video})
deprecated, use encoder private options instead
@item -rc_qmod_freq[:stream_specifier] @var{integer} (@emph{output,video})
deprecated, use encoder private options instead
@item -rc_eq[:stream_specifier] @var{string} (@emph{output,video})
deprecated, use encoder private options instead
@item -maxrate[:stream_specifier] @var{integer} (@emph{output,audio,video})
maximum bitrate (in bits/s). Used for VBV together with bufsize.
@item -minrate[:stream_specifier] @var{integer} (@emph{output,audio,video})
minimum bitrate (in bits/s). Most useful in setting up a CBR encode. It is of little use otherwise.
@item -bufsize[:stream_specifier] @var{integer} (@emph{output,audio,video})
set ratecontrol buffer size (in bits)
@item -rc_buf_aggressivity[:stream_specifier] @var{float} (@emph{output,video})
deprecated, use encoder private options instead
@item -i_qfactor[:stream_specifier] @var{float} (@emph{output,video})
QP factor between P- and I-frames
@item -i_qoffset[:stream_specifier] @var{float} (@emph{output,video})
QP offset between P- and I-frames
@item -rc_init_cplx[:stream_specifier] @var{float} (@emph{output,video})
deprecated, use encoder private options instead
@item -dct[:stream_specifier] @var{integer} (@emph{output,video})
DCT algorithm

Possible values:
@table @samp
@item auto
autoselect a good one
@item fastint
fast integer
@item int
accurate integer
@item mmx

@item altivec

@item faan
floating point AAN DCT
@end table
@item -lumi_mask[:stream_specifier] @var{float} (@emph{output,video})
compresses bright areas stronger than medium ones
@item -tcplx_mask[:stream_specifier] @var{float} (@emph{output,video})
temporal complexity masking
@item -scplx_mask[:stream_specifier] @var{float} (@emph{output,video})
spatial complexity masking
@item -p_mask[:stream_specifier] @var{float} (@emph{output,video})
inter masking
@item -dark_mask[:stream_specifier] @var{float} (@emph{output,video})
compresses dark areas stronger than medium ones
@item -idct[:stream_specifier] @var{integer} (@emph{input/output,video})
select IDCT implementation

Possible values:
@table @samp
@item auto

@item int

@item simple

@item simplemmx

@item arm

@item altivec

@item sh4

@item simplearm

@item simplearmv5te

@item simplearmv6

@item simpleneon

@item simplealpha

@item ipp

@item xvid

@item xvidmmx
deprecated, for compatibility only
@item faani
floating point AAN IDCT
@item simpleauto

@end table
@item -ec[:stream_specifier] @var{flags} (@emph{input,video})
set error concealment strategy

Possible values:
@table @samp
@item guess_mvs
iterative motion vector (MV) search (slow)
@item deblock
use strong deblock filter for damaged MBs
@item favor_inter
favor predicting from the previous frame
@end table
@item -pred[:stream_specifier] @var{integer} (@emph{output,video})
prediction method

Possible values:
@table @samp
@item left

@item plane

@item median

@end table
@item -aspect[:stream_specifier] @var{rational number} (@emph{output,video})
sample aspect ratio
@item -sar[:stream_specifier] @var{rational number} (@emph{output,video})
sample aspect ratio
@item -debug[:stream_specifier] @var{flags} (@emph{input/output,audio,video,subtitles})
print specific debug info

Possible values:
@table @samp
@item pict
picture info
@item rc
rate control
@item bitstream

@item mb_type
macroblock (MB) type
@item qp
per-block quantization parameter (QP)
@item mv
motion vector
@item dct_coeff

@item green_metadata

@item skip

@item startcode

@item pts

@item er
error recognition
@item mmco
memory management control operations (H.264)
@item bugs

@item vis_qp
visualize quantization parameter (QP), lower QP are tinted greener
@item vis_mb_type
visualize block types
@item buffers
picture buffer allocations
@item thread_ops
threading operations
@item nomc
skip motion compensation
@end table
@item -vismv[:stream_specifier] @var{flags} (@emph{input,video})
visualize motion vectors (MVs) (deprecated)

Possible values:
@table @samp
@item pf
forward predicted MVs of P-frames
@item bf
forward predicted MVs of B-frames
@item bb
backward predicted MVs of B-frames
@end table
@item -cmp[:stream_specifier] @var{integer} (@emph{output,video})
full-pel ME compare function

Possible values:
@table @samp
@item sad
sum of absolute differences, fast
@item sse
sum of squared errors
@item satd
sum of absolute Hadamard transformed differences
@item dct
sum of absolute DCT transformed differences
@item psnr
sum of squared quantization errors (avoid, low quality)
@item bit
number of bits needed for the block
@item rd
rate distortion optimal, slow
@item zero
0
@item vsad
sum of absolute vertical differences
@item vsse
sum of squared vertical differences
@item nsse
noise preserving sum of squared differences
@item dctmax

@item chroma

@item msad
sum of absolute differences, median predicted
@end table
@item -subcmp[:stream_specifier] @var{integer} (@emph{output,video})
sub-pel ME compare function

Possible values:
@table @samp
@item sad
sum of absolute differences, fast
@item sse
sum of squared errors
@item satd
sum of absolute Hadamard transformed differences
@item dct
sum of absolute DCT transformed differences
@item psnr
sum of squared quantization errors (avoid, low quality)
@item bit
number of bits needed for the block
@item rd
rate distortion optimal, slow
@item zero
0
@item vsad
sum of absolute vertical differences
@item vsse
sum of squared vertical differences
@item nsse
noise preserving sum of squared differences
@item dctmax

@item chroma

@item msad
sum of absolute differences, median predicted
@end table
@item -mbcmp[:stream_specifier] @var{integer} (@emph{output,video})
macroblock compare function

Possible values:
@table @samp
@item sad
sum of absolute differences, fast
@item sse
sum of squared errors
@item satd
sum of absolute Hadamard transformed differences
@item dct
sum of absolute DCT transformed differences
@item psnr
sum of squared quantization errors (avoid, low quality)
@item bit
number of bits needed for the block
@item rd
rate distortion optimal, slow
@item zero
0
@item vsad
sum of absolute vertical differences
@item vsse
sum of squared vertical differences
@item nsse
noise preserving sum of squared differences
@item dctmax

@item chroma

@item msad
sum of absolute differences, median predicted
@end table
@item -ildctcmp[:stream_specifier] @var{integer} (@emph{output,video})
interlaced DCT compare function

Possible values:
@table @samp
@item sad
sum of absolute differences, fast
@item sse
sum of squared errors
@item satd
sum of absolute Hadamard transformed differences
@item dct
sum of absolute DCT transformed differences
@item psnr
sum of squared quantization errors (avoid, low quality)
@item bit
number of bits needed for the block
@item rd
rate distortion optimal, slow
@item zero
0
@item vsad
sum of absolute vertical differences
@item vsse
sum of squared vertical differences
@item nsse
noise preserving sum of squared differences
@item dctmax

@item chroma

@item msad
sum of absolute differences, median predicted
@end table
@item -dia_size[:stream_specifier] @var{integer} (@emph{output,video})
diamond type & size for motion estimation
@item -last_pred[:stream_specifier] @var{integer} (@emph{output,video})
amount of motion predictors from the previous frame
@item -preme[:stream_specifier] @var{integer} (@emph{output,video})
pre motion estimation
@item -precmp[:stream_specifier] @var{integer} (@emph{output,video})
pre motion estimation compare function

Possible values:
@table @samp
@item sad
sum of absolute differences, fast
@item sse
sum of squared errors
@item satd
sum of absolute Hadamard transformed differences
@item dct
sum of absolute DCT transformed differences
@item psnr
sum of squared quantization errors (avoid, low quality)
@item bit
number of bits needed for the block
@item rd
rate distortion optimal, slow
@item zero
0
@item vsad
sum of absolute vertical differences
@item vsse
sum of squared vertical differences
@item nsse
noise preserving sum of squared differences
@item dctmax

@item chroma

@item msad
sum of absolute differences, median predicted
@end table
@item -pre_dia_size[:stream_specifier] @var{integer} (@emph{output,video})
diamond type & size for motion estimation pre-pass
@item -subq[:stream_specifier] @var{integer} (@emph{output,video})
sub-pel motion estimation quality
@item -me_range[:stream_specifier] @var{integer} (@emph{output,video})
limit motion vectors range (1023 for DivX player)
@item -ibias[:stream_specifier] @var{integer} (@emph{output,video})
intra quant bias
@item -pbias[:stream_specifier] @var{integer} (@emph{output,video})
inter quant bias
@item -global_quality[:stream_specifier] @var{integer} (@emph{output,audio,video})
@item -coder[:stream_specifier] @var{integer} (@emph{output,video})

Possible values:
@table @samp
@item vlc
variable length coder / Huffman coder
@item ac
arithmetic coder
@item raw
raw (no encoding)
@item rle
run-length coder
@item deflate
deflate-based coder
@end table
@item -context[:stream_specifier] @var{integer} (@emph{output,video})
context model
@item -mbd[:stream_specifier] @var{integer} (@emph{output,video})
macroblock decision algorithm (high quality mode)

Possible values:
@table @samp
@item simple
use mbcmp
@item bits
use fewest bits
@item rd
use best rate distortion
@end table
@item -sc_threshold[:stream_specifier] @var{integer} (@emph{output,video})
scene change threshold
@item -lmin[:stream_specifier] @var{integer} (@emph{output,video})
deprecated, use encoder private options instead
@item -lmax[:stream_specifier] @var{integer} (@emph{output,video})
deprecated, use encoder private options instead
@item -nr[:stream_specifier] @var{integer} (@emph{output,video})
noise reduction
@item -rc_init_occupancy[:stream_specifier] @var{integer} (@emph{output,video})
number of bits which should be loaded into the rc buffer before decoding starts
@item -flags2[:stream_specifier] @var{flags} (@emph{input/output,audio,video})

Possible values:
@table @samp
@item fast
allow non-spec-compliant speedup tricks
@item noout
skip bitstream encoding
@item ignorecrop
ignore cropping information from sps
@item local_header
place global headers at every keyframe instead of in extradata
@item chunks
Frame data might be split into multiple chunks
@item showall
Show all frames before the first keyframe
@item export_mvs
export motion vectors through frame side data
@item skip_manual
do not skip samples and export skip information as frame side data
@item ass_ro_flush_noop
do not reset ASS ReadOrder field on flush
@end table
@item -error[:stream_specifier] @var{integer} (@emph{output,video})
@item -threads[:stream_specifier] @var{integer} (@emph{input/output,audio,video})
set the number of threads

Possible values:
@table @samp
@item auto
autodetect a suitable number of threads to use
@end table
@item -me_threshold[:stream_specifier] @var{integer} (@emph{output,video})
motion estimation threshold
@item -mb_threshold[:stream_specifier] @var{integer} (@emph{output,video})
macroblock threshold
@item -dc[:stream_specifier] @var{integer} (@emph{output,video})
intra_dc_precision
@item -nssew[:stream_specifier] @var{integer} (@emph{output,video})
nsse weight
@item -skip_top[:stream_specifier] @var{integer} (@emph{input,video})
number of macroblock rows at the top which are skipped
@item -skip_bottom[:stream_specifier] @var{integer} (@emph{input,video})
number of macroblock rows at the bottom which are skipped
@item -profile[:stream_specifier] @var{integer} (@emph{output,audio,video})

Possible values:
@table @samp
@item unknown

@item aac_main

@item aac_low

@item aac_ssr

@item aac_ltp

@item aac_he

@item aac_he_v2

@item aac_ld

@item aac_eld

@item mpeg2_aac_low

@item mpeg2_aac_he

@item dts

@item dts_es

@item dts_96_24

@item dts_hd_hra

@item dts_hd_ma

@item mpeg4_sp

@item mpeg4_core

@item mpeg4_main

@item mpeg4_asp

@end table
@item -level[:stream_specifier] @var{integer} (@emph{output,audio,video})

Possible values:
@table @samp
@item unknown

@end table
@item -lowres[:stream_specifier] @var{integer} (@emph{input,audio,video})
decode at 1= 1/2, 2=1/4, 3=1/8 resolutions
@item -skip_threshold[:stream_specifier] @var{integer} (@emph{output,video})
frame skip threshold
@item -skip_factor[:stream_specifier] @var{integer} (@emph{output,video})
frame skip factor
@item -skip_exp[:stream_specifier] @var{integer} (@emph{output,video})
frame skip exponent
@item -skipcmp[:stream_specifier] @var{integer} (@emph{output,video})
frame skip compare function

Possible values:
@table @samp
@item sad
sum of absolute differences, fast
@item sse
sum of squared errors
@item satd
sum of absolute Hadamard transformed differences
@item dct
sum of absolute DCT transformed differences
@item psnr
sum of squared quantization errors (avoid, low quality)
@item bit
number of bits needed for the block
@item rd
rate distortion optimal, slow
@item zero
0
@item vsad
sum of absolute vertical differences
@item vsse
sum of squared vertical differences
@item nsse
noise preserving sum of squared differences
@item dctmax

@item chroma

@item msad
sum of absolute differences, median predicted
@end table
@item -border_mask[:stream_specifier] @var{float} (@emph{output,video})
deprecated, use encoder private options instead
@item -mblmin[:stream_specifier] @var{integer} (@emph{output,video})
minimum macroblock Lagrange factor (VBR)
@item -mblmax[:stream_specifier] @var{integer} (@emph{output,video})
maximum macroblock Lagrange factor (VBR)
@item -mepc[:stream_specifier] @var{integer} (@emph{output,video})
motion estimation bitrate penalty compensation (1.0 = 256)
@item -skip_loop_filter[:stream_specifier] @var{integer} (@emph{input,video})
skip loop filtering process for the selected frames

Possible values:
@table @samp
@item none
discard no frame
@item default
discard useless frames
@item noref
discard all non-reference frames
@item bidir
discard all bidirectional frames
@item nokey
discard all frames except keyframes
@item nointra
discard all frames except I frames
@item all
discard all frames
@end table
@item -skip_idct[:stream_specifier] @var{integer} (@emph{input,video})
skip IDCT/dequantization for the selected frames

Possible values:
@table @samp
@item none
discard no frame
@item default
discard useless frames
@item noref
discard all non-reference frames
@item bidir
discard all bidirectional frames
@item nokey
discard all frames except keyframes
@item nointra
discard all frames except I frames
@item all
discard all frames
@end table
@item -skip_frame[:stream_specifier] @var{integer} (@emph{input,video})
skip decoding for the selected frames

Possible values:
@table @samp
@item none
discard no frame
@item default
discard useless frames
@item noref
discard all non-reference frames
@item bidir
discard all bidirectional frames
@item nokey
discard all frames except keyframes
@item nointra
discard all frames except I frames
@item all
discard all frames
@end table
@item -bidir_refine[:stream_specifier] @var{integer} (@emph{output,video})
refine the two motion vectors used in bidirectional macroblocks
@item -brd_scale[:stream_specifier] @var{integer} (@emph{output,video})
downscale frames for dynamic B-frame decision
@item -keyint_min[:stream_specifier] @var{integer} (@emph{output,video})
minimum interval between IDR-frames
@item -refs[:stream_specifier] @var{integer} (@emph{output,video})
reference frames to consider for motion compensation
@item -chromaoffset[:stream_specifier] @var{integer} (@emph{output,video})
chroma QP offset from luma
@item -trellis[:stream_specifier] @var{integer} (@emph{output,audio,video})
rate-distortion optimal quantization
@item -sc_factor[:stream_specifier] @var{integer} (@emph{output,video})
multiplied by qscale for each frame and added to scene_change_score
@item -mv0_threshold[:stream_specifier] @var{integer} (@emph{output,video})
@item -b_sensitivity[:stream_specifier] @var{integer} (@emph{output,video})
adjust sensitivity of b_frame_strategy 1
@item -compression_level[:stream_specifier] @var{integer} (@emph{output,audio,video})
@item -min_prediction_order[:stream_specifier] @var{integer} (@emph{output,audio})
@item -max_prediction_order[:stream_specifier] @var{integer} (@emph{output,audio})
@item -timecode_frame_start[:stream_specifier] @var{integer} (@emph{output,video})
GOP timecode frame start number, in non-drop-frame format
@item -channel_layout[:stream_specifier] @var{integer} (@emph{input/output,audio})

Possible values:
@table @samp
@end table
@item -request_channel_layout[:stream_specifier] @var{integer} (@emph{input,audio})

Possible values:
@table @samp
@end table
@item -rc_max_vbv_use[:stream_specifier] @var{float} (@emph{output,video})
@item -rc_min_vbv_use[:stream_specifier] @var{float} (@emph{output,video})
@item -ticks_per_frame[:stream_specifier] @var{integer} (@emph{input/output,audio,video})
@item -color_primaries[:stream_specifier] @var{integer} (@emph{input/output,video})
color primaries

Possible values:
@table @samp
@item bt709
BT.709
@item unspecified
Unspecified
@item bt470m
BT.470 M
@item bt470bg
BT.470 BG
@item smpte170m
SMPTE 170 M
@item smpte240m
SMPTE 240 M
@item film
Film
@item bt2020
BT.2020
@item smpte428_1
SMPTE ST 428-1
@item smpte431
SMPTE 431-2
@item smpte432
SMPTE 422-1
@end table
@item -color_trc[:stream_specifier] @var{integer} (@emph{input/output,video})
color transfer characteristics

Possible values:
@table @samp
@item bt709
BT.709
@item unspecified
Unspecified
@item gamma22
BT.470 M
@item gamma28
BT.470 BG
@item smpte170m
SMPTE 170 M
@item smpte240m
SMPTE 240 M
@item linear
Linear
@item log
Log
@item log_sqrt
Log square root
@item iec61966_2_4
IEC 61966-2-4
@item bt1361
BT.1361
@item iec61966_2_1
IEC 61966-2-1
@item bt2020_10bit
BT.2020 - 10 bit
@item bt2020_12bit
BT.2020 - 12 bit
@item smpte2084
SMPTE ST 2084
@item smpte428_1
SMPTE ST 428-1
@item arib-std-b67
ARIB STD-B67
@end table
@item -colorspace[:stream_specifier] @var{integer} (@emph{input/output,video})
color space

Possible values:
@table @samp
@item rgb
RGB
@item bt709
BT.709
@item unspecified
Unspecified
@item fcc
FCC
@item bt470bg
BT.470 BG
@item smpte170m
SMPTE 170 M
@item smpte240m
SMPTE 240 M
@item ycocg
YCOCG
@item bt2020_ncl
BT.2020 NCL
@item bt2020_cl
BT.2020 CL
@item smpte2085
SMPTE 2085
@end table
@item -color_range[:stream_specifier] @var{integer} (@emph{input/output,video})
color range

Possible values:
@table @samp
@item unspecified
Unspecified
@item mpeg
MPEG (219*2^(n-8))
@item jpeg
JPEG (2^n-1)
@end table
@item -chroma_sample_location[:stream_specifier] @var{integer} (@emph{input/output,video})
chroma sample location

Possible values:
@table @samp
@item unspecified
Unspecified
@item left
Left
@item center
Center
@item topleft
Top-left
@item top
Top
@item bottomleft
Bottom-left
@item bottom
Bottom
@end table
@item -slices[:stream_specifier] @var{integer} (@emph{output,video})
set the number of slices, used in parallelized encoding
@item -thread_type[:stream_specifier] @var{flags} (@emph{input/output,audio,video})
select multithreading type

Possible values:
@table @samp
@item slice

@item frame

@end table
@item -audio_service_type[:stream_specifier] @var{integer} (@emph{output,audio})
audio service type

Possible values:
@table @samp
@item ma
Main Audio Service
@item ef
Effects
@item vi
Visually Impaired
@item hi
Hearing Impaired
@item di
Dialogue
@item co
Commentary
@item em
Emergency
@item vo
Voice Over
@item ka
Karaoke
@end table
@item -request_sample_fmt[:stream_specifier] @var{value} (@emph{input,audio})
sample format audio decoders should prefer

Possible values:
@table @samp
@end table
@item -sub_charenc[:stream_specifier] @var{string} (@emph{input,subtitles})
set input text subtitles character encoding
@item -sub_charenc_mode[:stream_specifier] @var{flags} (@emph{input,subtitles})
set input text subtitles character encoding mode

Possible values:
@table @samp
@item do_nothing

@item auto

@item pre_decoder

@end table
@item -sub_text_format[:stream_specifier] @var{integer} (@emph{input,subtitles})
set decoded text subtitle format

Possible values:
@table @samp
@item ass

@item ass_with_timings

@end table
@item -refcounted_frames[:stream_specifier] @var{value} (@emph{input,audio,video})
@item -side_data_only_packets[:stream_specifier] @var{value} (@emph{output,audio,video})
@item -skip_alpha[:stream_specifier] @var{value} (@emph{input,video})
Skip processing alpha
@item -field_order[:stream_specifier] @var{integer} (@emph{input/output,video})
Field order

Possible values:
@table @samp
@item progressive

@item tt

@item bb

@item tb

@item bt

@end table
@item -dump_separator[:stream_specifier] @var{string} (@emph{input/output,audio,video,subtitles})
set information dump field separator
@item -codec_whitelist[:stream_specifier] @var{string} (@emph{input,audio,video,subtitles})
List of decoders that are allowed to be used
@end table
