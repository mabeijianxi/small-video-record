.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FFMPEG-FORMATS 1"
.TH FFMPEG-FORMATS 1 " " " " " "
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ffmpeg\-formats \- FFmpeg formats
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes the supported formats (muxers and demuxers)
provided by the libavformat library.
.SH "FORMAT OPTIONS"
.IX Header "FORMAT OPTIONS"
The libavformat library provides some generic global options, which
can be set on all the muxers and demuxers. In addition each muxer or
demuxer may support so-called private options, which are specific for
that component.
.PP
Options may be set by specifying \-\fIoption\fR \fIvalue\fR in the
FFmpeg tools, or by setting the value explicitly in the
\&\f(CW\*(C`AVFormatContext\*(C'\fR options or using the \fIlibavutil/opt.h\fR \s-1API\s0
for programmatic use.
.PP
The list of supported options follows:
.IP "\fBavioflags\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "avioflags flags (input/output)"
Possible values:
.RS 4
.IP "\fBdirect\fR" 4
.IX Item "direct"
Reduce buffering.
.RE
.RS 4
.RE
.IP "\fBprobesize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "probesize integer (input)"
Set probing size in bytes, i.e. the size of the data to analyze to get
stream information. A higher value will enable detecting more
information in case it is dispersed into the stream, but will increase
latency. Must be an integer not lesser than 32. It is 5000000 by default.
.IP "\fBpacketsize\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "packetsize integer (output)"
Set packet size.
.IP "\fBfflags\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "fflags flags (input/output)"
Set format flags.
.Sp
Possible values:
.RS 4
.IP "\fBignidx\fR" 4
.IX Item "ignidx"
Ignore index.
.IP "\fBfastseek\fR" 4
.IX Item "fastseek"
Enable fast, but inaccurate seeks for some formats.
.IP "\fBgenpts\fR" 4
.IX Item "genpts"
Generate \s-1PTS.\s0
.IP "\fBnofillin\fR" 4
.IX Item "nofillin"
Do not fill in missing values that can be exactly calculated.
.IP "\fBnoparse\fR" 4
.IX Item "noparse"
Disable AVParsers, this needs \f(CW\*(C`+nofillin\*(C'\fR too.
.IP "\fBigndts\fR" 4
.IX Item "igndts"
Ignore \s-1DTS.\s0
.IP "\fBdiscardcorrupt\fR" 4
.IX Item "discardcorrupt"
Discard corrupted frames.
.IP "\fBsortdts\fR" 4
.IX Item "sortdts"
Try to interleave output packets by \s-1DTS.\s0
.IP "\fBkeepside\fR" 4
.IX Item "keepside"
Do not merge side data.
.IP "\fBlatm\fR" 4
.IX Item "latm"
Enable \s-1RTP MP4A\-LATM\s0 payload.
.IP "\fBnobuffer\fR" 4
.IX Item "nobuffer"
Reduce the latency introduced by optional buffering
.IP "\fBbitexact\fR" 4
.IX Item "bitexact"
Only write platform\-, build\- and time-independent data.
This ensures that file and data checksums are reproducible and match between
platforms. Its primary use is for regression testing.
.IP "\fBshortest\fR" 4
.IX Item "shortest"
Stop muxing at the end of the shortest stream.
It may be needed to increase max_interleave_delta to avoid flushing the longer
streams before \s-1EOF.\s0
.RE
.RS 4
.RE
.IP "\fBseek2any\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "seek2any integer (input)"
Allow seeking to non-keyframes on demuxer level when supported if set to 1.
Default is 0.
.IP "\fBanalyzeduration\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "analyzeduration integer (input)"
Specify how many microseconds are analyzed to probe the input. A
higher value will enable detecting more accurate information, but will
increase latency. It defaults to 5,000,000 microseconds = 5 seconds.
.IP "\fBcryptokey\fR \fIhexadecimal string\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "cryptokey hexadecimal string (input)"
Set decryption key.
.IP "\fBindexmem\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "indexmem integer (input)"
Set max memory used for timestamp index (per stream).
.IP "\fBrtbufsize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "rtbufsize integer (input)"
Set max memory used for buffering real-time frames.
.IP "\fBfdebug\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "fdebug flags (input/output)"
Print specific debug info.
.Sp
Possible values:
.RS 4
.IP "\fBts\fR" 4
.IX Item "ts"
.RE
.RS 4
.RE
.PD 0
.IP "\fBmax_delay\fR \fIinteger\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "max_delay integer (input/output)"
.PD
Set maximum muxing or demuxing delay in microseconds.
.IP "\fBfpsprobesize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "fpsprobesize integer (input)"
Set number of frames used to probe fps.
.IP "\fBaudio_preload\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "audio_preload integer (output)"
Set microseconds by which audio packets should be interleaved earlier.
.IP "\fBchunk_duration\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "chunk_duration integer (output)"
Set microseconds for each chunk.
.IP "\fBchunk_size\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "chunk_size integer (output)"
Set size in bytes for each chunk.
.IP "\fBerr_detect, f_err_detect\fR \fIflags\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "err_detect, f_err_detect flags (input)"
Set error detection flags. \f(CW\*(C`f_err_detect\*(C'\fR is deprecated and
should be used only via the \fBffmpeg\fR tool.
.Sp
Possible values:
.RS 4
.IP "\fBcrccheck\fR" 4
.IX Item "crccheck"
Verify embedded CRCs.
.IP "\fBbitstream\fR" 4
.IX Item "bitstream"
Detect bitstream specification deviations.
.IP "\fBbuffer\fR" 4
.IX Item "buffer"
Detect improper bitstream length.
.IP "\fBexplode\fR" 4
.IX Item "explode"
Abort decoding on minor error detection.
.IP "\fBcareful\fR" 4
.IX Item "careful"
Consider things that violate the spec and have not been seen in the
wild as errors.
.IP "\fBcompliant\fR" 4
.IX Item "compliant"
Consider all spec non compliancies as errors.
.IP "\fBaggressive\fR" 4
.IX Item "aggressive"
Consider things that a sane encoder should not do as an error.
.RE
.RS 4
.RE
.IP "\fBmax_interleave_delta\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "max_interleave_delta integer (output)"
Set maximum buffering duration for interleaving. The duration is
expressed in microseconds, and defaults to 1000000 (1 second).
.Sp
To ensure all the streams are interleaved correctly, libavformat will
wait until it has at least one packet for each stream before actually
writing any packets to the output file. When some streams are
\&\*(L"sparse\*(R" (i.e. there are large gaps between successive packets), this
can result in excessive buffering.
.Sp
This field specifies the maximum difference between the timestamps of the
first and the last packet in the muxing queue, above which libavformat
will output a packet regardless of whether it has queued a packet for all
the streams.
.Sp
If set to 0, libavformat will continue buffering packets until it has
a packet for each stream, regardless of the maximum timestamp
difference between the buffered packets.
.IP "\fBuse_wallclock_as_timestamps\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "use_wallclock_as_timestamps integer (input)"
Use wallclock as timestamps if set to 1. Default is 0.
.IP "\fBavoid_negative_ts\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "avoid_negative_ts integer (output)"
Possible values:
.RS 4
.IP "\fBmake_non_negative\fR" 4
.IX Item "make_non_negative"
Shift timestamps to make them non-negative.
Also note that this affects only leading negative timestamps, and not
non-monotonic negative timestamps.
.IP "\fBmake_zero\fR" 4
.IX Item "make_zero"
Shift timestamps so that the first timestamp is 0.
.IP "\fBauto (default)\fR" 4
.IX Item "auto (default)"
Enables shifting when required by the target format.
.IP "\fBdisabled\fR" 4
.IX Item "disabled"
Disables shifting of timestamp.
.RE
.RS 4
.Sp
When shifting is enabled, all output timestamps are shifted by the
same amount. Audio, video, and subtitles desynching and relative
timestamp differences are preserved compared to how they would have
been without shifting.
.RE
.IP "\fBskip_initial_bytes\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "skip_initial_bytes integer (input)"
Set number of bytes to skip before reading header and frames if set to 1.
Default is 0.
.IP "\fBcorrect_ts_overflow\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "correct_ts_overflow integer (input)"
Correct single timestamp overflows if set to 1. Default is 1.
.IP "\fBflush_packets\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "flush_packets integer (output)"
Flush the underlying I/O stream after each packet. Default 1 enables it, and
has the effect of reducing the latency; 0 disables it and may slightly
increase performance in some cases.
.IP "\fBoutput_ts_offset\fR \fIoffset\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "output_ts_offset offset (output)"
Set the output time offset.
.Sp
\&\fIoffset\fR must be a time duration specification,
see \fBthe Time duration section in the \f(BIffmpeg\-utils\fB\|(1) manual\fR.
.Sp
The offset is added by the muxer to the output timestamps.
.Sp
Specifying a positive offset means that the corresponding streams are
delayed bt the time duration specified in \fIoffset\fR. Default value
is \f(CW0\fR (meaning that no offset is applied).
.IP "\fBformat_whitelist\fR \fIlist\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "format_whitelist list (input)"
\&\*(L",\*(R" separated list of allowed demuxers. By default all are allowed.
.IP "\fBdump_separator\fR \fIstring\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "dump_separator string (input)"
Separator used to separate the fields printed on the command line about the
Stream parameters.
For example to separate the fields with newlines and indention:
.Sp
.Vb 2
\&        ffprobe \-dump_separator "
\&                                  "  \-i ~/videos/matrixbench_mpeg2.mpg
.Ve
.IP "\fBmax_streams\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "max_streams integer (input)"
Specifies the maximum number of streams. This can be used to reject files that
would require too many resources due to a large number of streams.
.SS "Format stream specifiers"
.IX Subsection "Format stream specifiers"
Format stream specifiers allow selection of one or more streams that
match specific properties.
.PP
Possible forms of stream specifiers are:
.IP "\fIstream_index\fR" 4
.IX Item "stream_index"
Matches the stream with this index.
.IP "\fIstream_type\fR\fB[:\fR\fIstream_index\fR\fB]\fR" 4
.IX Item "stream_type[:stream_index]"
\&\fIstream_type\fR is one of following: 'v' for video, 'a' for audio,
\&'s' for subtitle, 'd' for data, and 't' for attachments. If
\&\fIstream_index\fR is given, then it matches the stream number
\&\fIstream_index\fR of this type. Otherwise, it matches all streams of
this type.
.IP "\fBp:\fR\fIprogram_id\fR\fB[:\fR\fIstream_index\fR\fB]\fR" 4
.IX Item "p:program_id[:stream_index]"
If \fIstream_index\fR is given, then it matches the stream with number
\&\fIstream_index\fR in the program with the id
\&\fIprogram_id\fR. Otherwise, it matches all streams in the program.
.IP "\fB#\fR\fIstream_id\fR" 4
.IX Item "#stream_id"
Matches the stream by a format-specific \s-1ID.\s0
.PP
The exact semantics of stream specifiers is defined by the
\&\f(CW\*(C`avformat_match_stream_specifier()\*(C'\fR function declared in the
\&\fIlibavformat/avformat.h\fR header.
.SH "DEMUXERS"
.IX Header "DEMUXERS"
Demuxers are configured elements in FFmpeg that can read the
multimedia streams from a particular type of file.
.PP
When you configure your FFmpeg build, all the supported demuxers
are enabled by default. You can list all available ones using the
configure option \f(CW\*(C`\-\-list\-demuxers\*(C'\fR.
.PP
You can disable all the demuxers using the configure option
\&\f(CW\*(C`\-\-disable\-demuxers\*(C'\fR, and selectively enable a single demuxer with
the option \f(CW\*(C`\-\-enable\-demuxer=\f(CIDEMUXER\f(CW\*(C'\fR, or disable it
with the option \f(CW\*(C`\-\-disable\-demuxer=\f(CIDEMUXER\f(CW\*(C'\fR.
.PP
The option \f(CW\*(C`\-formats\*(C'\fR of the ff* tools will display the list of
enabled demuxers.
.PP
The description of some of the currently available demuxers follows.
.SS "aa"
.IX Subsection "aa"
Audible Format 2, 3, and 4 demuxer.
.PP
This demuxer is used to demux Audible Format 2, 3, and 4 (.aa) files.
.SS "applehttp"
.IX Subsection "applehttp"
Apple \s-1HTTP\s0 Live Streaming demuxer.
.PP
This demuxer presents all AVStreams from all variant streams.
The id field is set to the bitrate variant index number. By setting
the discard flags on AVStreams (by pressing 'a' or 'v' in ffplay),
the caller can decide which variant streams to actually receive.
The total bitrate of the variant that the stream belongs to is
available in a metadata key named \*(L"variant_bitrate\*(R".
.SS "apng"
.IX Subsection "apng"
Animated Portable Network Graphics demuxer.
.PP
This demuxer is used to demux \s-1APNG\s0 files.
All headers, but the \s-1PNG\s0 signature, up to (but not including) the first
fcTL chunk are transmitted as extradata.
Frames are then split as being all the chunks between two fcTL ones, or
between the last fcTL and \s-1IEND\s0 chunks.
.IP "\fB\-ignore_loop\fR \fIbool\fR" 4
.IX Item "-ignore_loop bool"
Ignore the loop variable in the file if set.
.IP "\fB\-max_fps\fR \fIint\fR" 4
.IX Item "-max_fps int"
Maximum framerate in frames per second (0 for no limit).
.IP "\fB\-default_fps\fR \fIint\fR" 4
.IX Item "-default_fps int"
Default framerate in frames per second when none is specified in the file
(0 meaning as fast as possible).
.SS "asf"
.IX Subsection "asf"
Advanced Systems Format demuxer.
.PP
This demuxer is used to demux \s-1ASF\s0 files and \s-1MMS\s0 network streams.
.IP "\fB\-no_resync_search\fR \fIbool\fR" 4
.IX Item "-no_resync_search bool"
Do not try to resynchronize by looking for a certain optional start code.
.SS "concat"
.IX Subsection "concat"
Virtual concatenation script demuxer.
.PP
This demuxer reads a list of files and other directives from a text file and
demuxes them one after the other, as if all their packets had been muxed
together.
.PP
The timestamps in the files are adjusted so that the first file starts at 0
and each next file starts where the previous one finishes. Note that it is
done globally and may cause gaps if all streams do not have exactly the same
length.
.PP
All files must have the same streams (same codecs, same time base, etc.).
.PP
The duration of each file is used to adjust the timestamps of the next file:
if the duration is incorrect (because it was computed using the bit-rate or
because the file is truncated, for example), it can cause artifacts. The
\&\f(CW\*(C`duration\*(C'\fR directive can be used to override the duration stored in
each file.
.PP
\fISyntax\fR
.IX Subsection "Syntax"
.PP
The script is a text file in extended-ASCII, with one directive per line.
Empty lines, leading spaces and lines starting with '#' are ignored. The
following directive is recognized:
.ie n .IP "\fB\fB""file \f(BIpath\f(CB""\fB\fR" 4
.el .IP "\fB\f(CBfile \f(CBpath\f(CB\fB\fR" 4
.IX Item "file path"
Path to a file to read; special characters and spaces must be escaped with
backslash or single quotes.
.Sp
All subsequent file-related directives apply to that file.
.ie n .IP "\fB\fB""ffconcat version 1.0""\fB\fR" 4
.el .IP "\fB\f(CBffconcat version 1.0\fB\fR" 4
.IX Item "ffconcat version 1.0"
Identify the script type and version. It also sets the \fBsafe\fR option
to 1 if it was \-1.
.Sp
To make FFmpeg recognize the format automatically, this directive must
appear exactly as is (no extra space or byte-order-mark) on the very first
line of the script.
.ie n .IP "\fB\fB""duration \f(BIdur\f(CB""\fB\fR" 4
.el .IP "\fB\f(CBduration \f(CBdur\f(CB\fB\fR" 4
.IX Item "duration dur"
Duration of the file. This information can be specified from the file;
specifying it here may be more efficient or help if the information from the
file is not available or accurate.
.Sp
If the duration is set for all files, then it is possible to seek in the
whole concatenated video.
.ie n .IP "\fB\fB""inpoint \f(BItimestamp\f(CB""\fB\fR" 4
.el .IP "\fB\f(CBinpoint \f(CBtimestamp\f(CB\fB\fR" 4
.IX Item "inpoint timestamp"
In point of the file. When the demuxer opens the file it instantly seeks to the
specified timestamp. Seeking is done so that all streams can be presented
successfully at In point.
.Sp
This directive works best with intra frame codecs, because for non-intra frame
ones you will usually get extra packets before the actual In point and the
decoded content will most likely contain frames before In point too.
.Sp
For each file, packets before the file In point will have timestamps less than
the calculated start timestamp of the file (negative in case of the first
file), and the duration of the files (if not specified by the \f(CW\*(C`duration\*(C'\fR
directive) will be reduced based on their specified In point.
.Sp
Because of potential packets before the specified In point, packet timestamps
may overlap between two concatenated files.
.ie n .IP "\fB\fB""outpoint \f(BItimestamp\f(CB""\fB\fR" 4
.el .IP "\fB\f(CBoutpoint \f(CBtimestamp\f(CB\fB\fR" 4
.IX Item "outpoint timestamp"
Out point of the file. When the demuxer reaches the specified decoding
timestamp in any of the streams, it handles it as an end of file condition and
skips the current and all the remaining packets from all streams.
.Sp
Out point is exclusive, which means that the demuxer will not output packets
with a decoding timestamp greater or equal to Out point.
.Sp
This directive works best with intra frame codecs and formats where all streams
are tightly interleaved. For non-intra frame codecs you will usually get
additional packets with presentation timestamp after Out point therefore the
decoded content will most likely contain frames after Out point too. If your
streams are not tightly interleaved you may not get all the packets from all
streams before Out point and you may only will be able to decode the earliest
stream until Out point.
.Sp
The duration of the files (if not specified by the \f(CW\*(C`duration\*(C'\fR
directive) will be reduced based on their specified Out point.
.ie n .IP "\fB\fB""file_packet_metadata \f(BIkey=value\f(CB""\fB\fR" 4
.el .IP "\fB\f(CBfile_packet_metadata \f(CBkey=value\f(CB\fB\fR" 4
.IX Item "file_packet_metadata key=value"
Metadata of the packets of the file. The specified metadata will be set for
each file packet. You can specify this directive multiple times to add multiple
metadata entries.
.ie n .IP "\fB\fB""stream""\fB\fR" 4
.el .IP "\fB\f(CBstream\fB\fR" 4
.IX Item "stream"
Introduce a stream in the virtual file.
All subsequent stream-related directives apply to the last introduced
stream.
Some streams properties must be set in order to allow identifying the
matching streams in the subfiles.
If no streams are defined in the script, the streams from the first file are
copied.
.ie n .IP "\fB\fB""exact_stream_id \f(BIid\f(CB""\fB\fR" 4
.el .IP "\fB\f(CBexact_stream_id \f(CBid\f(CB\fB\fR" 4
.IX Item "exact_stream_id id"
Set the id of the stream.
If this directive is given, the string with the corresponding id in the
subfiles will be used.
This is especially useful for MPEG-PS (\s-1VOB\s0) files, where the order of the
streams is not reliable.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
This demuxer accepts the following option:
.IP "\fBsafe\fR" 4
.IX Item "safe"
If set to 1, reject unsafe file paths. A file path is considered safe if it
does not contain a protocol specification and is relative and all components
only contain characters from the portable character set (letters, digits,
period, underscore and hyphen) and have no period at the beginning of a
component.
.Sp
If set to 0, any file name is accepted.
.Sp
The default is 1.
.Sp
\&\-1 is equivalent to 1 if the format was automatically
probed and 0 otherwise.
.IP "\fBauto_convert\fR" 4
.IX Item "auto_convert"
If set to 1, try to perform automatic conversions on packet data to make the
streams concatenable.
The default is 1.
.Sp
Currently, the only conversion is adding the h264_mp4toannexb bitstream
filter to H.264 streams in \s-1MP4\s0 format. This is necessary in particular if
there are resolution changes.
.IP "\fBsegment_time_metadata\fR" 4
.IX Item "segment_time_metadata"
If set to 1, every packet will contain the \fIlavf.concat.start_time\fR and the
\&\fIlavf.concat.duration\fR packet metadata values which are the start_time and
the duration of the respective file segments in the concatenated output
expressed in microseconds. The duration metadata is only set if it is known
based on the concat file.
The default is 0.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Use absolute filenames and include some comments:
.Sp
.Vb 6
\&        # my first filename
\&        file /mnt/share/file\-1.wav
\&        # my second filename including whitespace
\&        file \*(Aq/mnt/share/file 2.wav\*(Aq
\&        # my third filename including whitespace plus single quote
\&        file \*(Aq/mnt/share/file 3\*(Aq\e\*(Aq\*(Aq.wav\*(Aq
.Ve
.IP "\(bu" 4
Allow for input format auto-probing, use safe filenames and set the duration of
the first file:
.Sp
.Vb 1
\&        ffconcat version 1.0
\&        
\&        file file\-1.wav
\&        duration 20.0
\&        
\&        file subdir/file\-2.wav
.Ve
.SS "flv"
.IX Subsection "flv"
Adobe Flash Video Format demuxer.
.PP
This demuxer is used to demux \s-1FLV\s0 files and \s-1RTMP\s0 network streams.
.IP "\fB\-flv_metadata\fR \fIbool\fR" 4
.IX Item "-flv_metadata bool"
Allocate the streams according to the onMetaData array content.
.SS "gif"
.IX Subsection "gif"
Animated \s-1GIF\s0 demuxer.
.PP
It accepts the following options:
.IP "\fBmin_delay\fR" 4
.IX Item "min_delay"
Set the minimum valid delay between frames in hundredths of seconds.
Range is 0 to 6000. Default value is 2.
.IP "\fBmax_gif_delay\fR" 4
.IX Item "max_gif_delay"
Set the maximum valid delay between frames in hundredth of seconds.
Range is 0 to 65535. Default value is 65535 (nearly eleven minutes),
the maximum value allowed by the specification.
.IP "\fBdefault_delay\fR" 4
.IX Item "default_delay"
Set the default delay between frames in hundredths of seconds.
Range is 0 to 6000. Default value is 10.
.IP "\fBignore_loop\fR" 4
.IX Item "ignore_loop"
\&\s-1GIF\s0 files can contain information to loop a certain number of times (or
infinitely). If \fBignore_loop\fR is set to 1, then the loop setting
from the input will be ignored and looping will not occur. If set to 0,
then looping will occur and will cycle the number of times according to
the \s-1GIF.\s0 Default value is 1.
.PP
For example, with the overlay filter, place an infinitely looping \s-1GIF\s0
over another video:
.PP
.Vb 1
\&        ffmpeg \-i input.mp4 \-ignore_loop 0 \-i input.gif \-filter_complex overlay=shortest=1 out.mkv
.Ve
.PP
Note that in the above example the shortest option for overlay filter is
used to end the output video at the length of the shortest input file,
which in this case is \fIinput.mp4\fR as the \s-1GIF\s0 in this example loops
infinitely.
.SS "image2"
.IX Subsection "image2"
Image file demuxer.
.PP
This demuxer reads from a list of image files specified by a pattern.
The syntax and meaning of the pattern is specified by the
option \fIpattern_type\fR.
.PP
The pattern may contain a suffix which is used to automatically
determine the format of the images contained in the files.
.PP
The size, the pixel format, and the format of each image must be the
same for all the files in the sequence.
.PP
This demuxer accepts the following options:
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set the frame rate for the video stream. It defaults to 25.
.IP "\fBloop\fR" 4
.IX Item "loop"
If set to 1, loop over the input. Default value is 0.
.IP "\fBpattern_type\fR" 4
.IX Item "pattern_type"
Select the pattern type used to interpret the provided filename.
.Sp
\&\fIpattern_type\fR accepts one of the following values.
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
Disable pattern matching, therefore the video will only contain the specified
image. You should use this option if you do not want to create sequences from
multiple images and your filenames may contain special pattern characters.
.IP "\fBsequence\fR" 4
.IX Item "sequence"
Select a sequence pattern type, used to specify a sequence of files
indexed by sequential numbers.
.Sp
A sequence pattern may contain the string \*(L"%d\*(R" or "%0\fIN\fRd\*(L", which
specifies the position of the characters representing a sequential
number in each filename matched by the pattern. If the form
\&\*(R"%d0\fIN\fRd" is used, the string representing the number in each
filename is 0\-padded and \fIN\fR is the total number of 0\-padded
digits representing the number. The literal character '%' can be
specified in the pattern with the string \*(L"%%\*(R".
.Sp
If the sequence pattern contains \*(L"%d\*(R" or "%0\fIN\fRd", the first filename of
the file list specified by the pattern must contain a number
inclusively contained between \fIstart_number\fR and
\&\fIstart_number\fR+\fIstart_number_range\fR\-1, and all the following
numbers must be sequential.
.Sp
For example the pattern \*(L"img\-%03d.bmp\*(R" will match a sequence of
filenames of the form \fIimg\-001.bmp\fR, \fIimg\-002.bmp\fR, ...,
\&\fIimg\-010.bmp\fR, etc.; the pattern \*(L"i%%m%%g\-%d.jpg\*(R" will match a
sequence of filenames of the form \fIi%m%g\-1.jpg\fR,
\&\fIi%m%g\-2.jpg\fR, ..., \fIi%m%g\-10.jpg\fR, etc.
.Sp
Note that the pattern must not necessarily contain \*(L"%d\*(R" or
"%0\fIN\fRd", for example to convert a single image file
\&\fIimg.jpeg\fR you can employ the command:
.Sp
.Vb 1
\&        ffmpeg \-i img.jpeg img.png
.Ve
.IP "\fBglob\fR" 4
.IX Item "glob"
Select a glob wildcard pattern type.
.Sp
The pattern is interpreted like a \f(CW\*(C`glob()\*(C'\fR pattern. This is only
selectable if libavformat was compiled with globbing support.
.IP "\fBglob_sequence\fR \fI(deprecated, will be removed)\fR" 4
.IX Item "glob_sequence (deprecated, will be removed)"
Select a mixed glob wildcard/sequence pattern.
.Sp
If your version of libavformat was compiled with globbing support, and
the provided pattern contains at least one glob meta character among
\&\f(CW\*(C`%*?[]{}\*(C'\fR that is preceded by an unescaped \*(L"%\*(R", the pattern is
interpreted like a \f(CW\*(C`glob()\*(C'\fR pattern, otherwise it is interpreted
like a sequence pattern.
.Sp
All glob special characters \f(CW\*(C`%*?[]{}\*(C'\fR must be prefixed
with \*(L"%\*(R". To escape a literal \*(L"%\*(R" you shall use \*(L"%%\*(R".
.Sp
For example the pattern \f(CW\*(C`foo\-%*.jpeg\*(C'\fR will match all the
filenames prefixed by \*(L"foo\-\*(R" and terminating with \*(L".jpeg\*(R", and
\&\f(CW\*(C`foo\-%?%?%?.jpeg\*(C'\fR will match all the filenames prefixed with
\&\*(L"foo\-\*(R", followed by a sequence of three characters, and terminating
with \*(L".jpeg\*(R".
.Sp
This pattern type is deprecated in favor of \fIglob\fR and
\&\fIsequence\fR.
.RE
.RS 4
.Sp
Default value is \fIglob_sequence\fR.
.RE
.IP "\fBpixel_format\fR" 4
.IX Item "pixel_format"
Set the pixel format of the images to read. If not specified the pixel
format is guessed from the first image file in the sequence.
.IP "\fBstart_number\fR" 4
.IX Item "start_number"
Set the index of the file matched by the image file pattern to start
to read from. Default value is 0.
.IP "\fBstart_number_range\fR" 4
.IX Item "start_number_range"
Set the index interval range to check when looking for the first image
file in the sequence, starting from \fIstart_number\fR. Default value
is 5.
.IP "\fBts_from_file\fR" 4
.IX Item "ts_from_file"
If set to 1, will set frame timestamp to modification time of image file. Note
that monotonity of timestamps is not provided: images go in the same order as
without this option. Default value is 0.
If set to 2, will set frame timestamp to the modification time of the image file in
nanosecond precision.
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set the video size of the images to read. If not specified the video
size is guessed from the first image file in the sequence.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Use \fBffmpeg\fR for creating a video from the images in the file
sequence \fIimg\-001.jpeg\fR, \fIimg\-002.jpeg\fR, ..., assuming an
input frame rate of 10 frames per second:
.Sp
.Vb 1
\&        ffmpeg \-framerate 10 \-i \*(Aqimg\-%03d.jpeg\*(Aq out.mkv
.Ve
.IP "\(bu" 4
As above, but start by reading from a file with index 100 in the sequence:
.Sp
.Vb 1
\&        ffmpeg \-framerate 10 \-start_number 100 \-i \*(Aqimg\-%03d.jpeg\*(Aq out.mkv
.Ve
.IP "\(bu" 4
Read images matching the \*(L"*.png\*(R" glob pattern , that is all the files
terminating with the \*(L".png\*(R" suffix:
.Sp
.Vb 1
\&        ffmpeg \-framerate 10 \-pattern_type glob \-i "*.png" out.mkv
.Ve
.SS "libgme"
.IX Subsection "libgme"
The Game Music Emu library is a collection of video game music file emulators.
.PP
See <\fBhttp://code.google.com/p/game\-music\-emu/\fR> for more information.
.PP
Some files have multiple tracks. The demuxer will pick the first track by
default. The \fBtrack_index\fR option can be used to select a different
track. Track indexes start at 0. The demuxer exports the number of tracks as
\&\fItracks\fR meta data entry.
.PP
For very large files, the \fBmax_size\fR option may have to be adjusted.
.SS "libopenmpt"
.IX Subsection "libopenmpt"
libopenmpt based module demuxer
.PP
See <\fBhttps://lib.openmpt.org/libopenmpt/\fR> for more information.
.PP
Some files have multiple subsongs (tracks) this can be set with the \fBsubsong\fR
option.
.PP
It accepts the following options:
.IP "\fBsubsong\fR" 4
.IX Item "subsong"
Set the subsong index. This can be either  'all', 'auto', or the index of the
subsong. Subsong indexes start at 0. The default is 'auto'.
.Sp
The default value is to let libopenmpt choose.
.IP "\fBlayout\fR" 4
.IX Item "layout"
Set the channel layout. Valid values are 1, 2, and 4 channel layouts.
The default value is \s-1STEREO.\s0
.IP "\fBsample_rate\fR" 4
.IX Item "sample_rate"
Set the sample rate for libopenmpt to output.
Range is from 1000 to \s-1INT_MAX.\s0 The value default is 48000.
.SS "mov/mp4/3gp/QuickTime"
.IX Subsection "mov/mp4/3gp/QuickTime"
QuickTime / \s-1MP4\s0 demuxer.
.PP
This demuxer accepts the following options:
.IP "\fBenable_drefs\fR" 4
.IX Item "enable_drefs"
Enable loading of external tracks, disabled by default.
Enabling this can theoretically leak information in some use cases.
.IP "\fBuse_absolute_path\fR" 4
.IX Item "use_absolute_path"
Allows loading of external tracks via absolute paths, disabled by default.
Enabling this poses a security risk. It should only be enabled if the source
is known to be non malicious.
.SS "mpegts"
.IX Subsection "mpegts"
\&\s-1MPEG\-2\s0 transport stream demuxer.
.PP
This demuxer accepts the following options:
.IP "\fBresync_size\fR" 4
.IX Item "resync_size"
Set size limit for looking up a new synchronization. Default value is
65536.
.IP "\fBfix_teletext_pts\fR" 4
.IX Item "fix_teletext_pts"
Override teletext packet \s-1PTS\s0 and \s-1DTS\s0 values with the timestamps calculated
from the \s-1PCR\s0 of the first program which the teletext stream is part of and is
not discarded. Default value is 1, set this option to 0 if you want your
teletext packet \s-1PTS\s0 and \s-1DTS\s0 values untouched.
.IP "\fBts_packetsize\fR" 4
.IX Item "ts_packetsize"
Output option carrying the raw packet size in bytes.
Show the detected raw packet size, cannot be set by the user.
.IP "\fBscan_all_pmts\fR" 4
.IX Item "scan_all_pmts"
Scan and combine all PMTs. The value is an integer with value from \-1
to 1 (\-1 means automatic setting, 1 means enabled, 0 means
disabled). Default value is \-1.
.SS "mpjpeg"
.IX Subsection "mpjpeg"
\&\s-1MJPEG\s0 encapsulated in multi-part \s-1MIME\s0 demuxer.
.PP
This demuxer allows reading of \s-1MJPEG,\s0 where each frame is represented as a part of
multipart/x\-mixed\-replace stream.
.IP "\fBstrict_mime_boundary\fR" 4
.IX Item "strict_mime_boundary"
Default implementation applies a relaxed standard to multi-part \s-1MIME\s0 boundary detection,
to prevent regression with numerous existing endpoints not generating a proper \s-1MIME
MJPEG\s0 stream. Turning this option on by setting it to 1 will result in a stricter check
of the boundary value.
.SS "rawvideo"
.IX Subsection "rawvideo"
Raw video demuxer.
.PP
This demuxer allows one to read raw video data. Since there is no header
specifying the assumed video parameters, the user must specify them
in order to be able to decode the data correctly.
.PP
This demuxer accepts the following options:
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set input video frame rate. Default value is 25.
.IP "\fBpixel_format\fR" 4
.IX Item "pixel_format"
Set the input video pixel format. Default value is \f(CW\*(C`yuv420p\*(C'\fR.
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set the input video size. This value must be specified explicitly.
.PP
For example to read a rawvideo file \fIinput.raw\fR with
\&\fBffplay\fR, assuming a pixel format of \f(CW\*(C`rgb24\*(C'\fR, a video
size of \f(CW\*(C`320x240\*(C'\fR, and a frame rate of 10 images per second, use
the command:
.PP
.Vb 1
\&        ffplay \-f rawvideo \-pixel_format rgb24 \-video_size 320x240 \-framerate 10 input.raw
.Ve
.SS "sbg"
.IX Subsection "sbg"
SBaGen script demuxer.
.PP
This demuxer reads the script language used by SBaGen
<\fBhttp://uazu.net/sbagen/\fR> to generate binaural beats sessions. A \s-1SBG\s0
script looks like that:
.PP
.Vb 9
\&        \-SE
\&        a: 300\-2.5/3 440+4.5/0
\&        b: 300\-2.5/0 440+4.5/3
\&        off: \-
\&        NOW      == a
\&        +0:07:00 == b
\&        +0:14:00 == a
\&        +0:21:00 == b
\&        +0:30:00    off
.Ve
.PP
A \s-1SBG\s0 script can mix absolute and relative timestamps. If the script uses
either only absolute timestamps (including the script start time) or only
relative ones, then its layout is fixed, and the conversion is
straightforward. On the other hand, if the script mixes both kind of
timestamps, then the \fI\s-1NOW\s0\fR reference for relative timestamps will be
taken from the current time of day at the time the script is read, and the
script layout will be frozen according to that reference. That means that if
the script is directly played, the actual times will match the absolute
timestamps up to the sound controller's clock accuracy, but if the user
somehow pauses the playback or seeks, all times will be shifted accordingly.
.SS "tedcaptions"
.IX Subsection "tedcaptions"
\&\s-1JSON\s0 captions used for <\fBhttp://www.ted.com/\fR>.
.PP
\&\s-1TED\s0 does not provide links to the captions, but they can be guessed from the
page. The file \fItools/bookmarklets.html\fR from the FFmpeg source tree
contains a bookmarklet to expose them.
.PP
This demuxer accepts the following option:
.IP "\fBstart_time\fR" 4
.IX Item "start_time"
Set the start time of the \s-1TED\s0 talk, in milliseconds. The default is 15000
(15s). It is used to sync the captions with the downloadable videos, because
they include a 15s intro.
.PP
Example: convert the captions to a format most players understand:
.PP
.Vb 1
\&        ffmpeg \-i http://www.ted.com/talks/subtitles/id/1/lang/en talk1\-en.srt
.Ve
.SH "MUXERS"
.IX Header "MUXERS"
Muxers are configured elements in FFmpeg which allow writing
multimedia streams to a particular type of file.
.PP
When you configure your FFmpeg build, all the supported muxers
are enabled by default. You can list all available muxers using the
configure option \f(CW\*(C`\-\-list\-muxers\*(C'\fR.
.PP
You can disable all the muxers with the configure option
\&\f(CW\*(C`\-\-disable\-muxers\*(C'\fR and selectively enable / disable single muxers
with the options \f(CW\*(C`\-\-enable\-muxer=\f(CIMUXER\f(CW\*(C'\fR /
\&\f(CW\*(C`\-\-disable\-muxer=\f(CIMUXER\f(CW\*(C'\fR.
.PP
The option \f(CW\*(C`\-formats\*(C'\fR of the ff* tools will display the list of
enabled muxers.
.PP
A description of some of the currently available muxers follows.
.SS "aiff"
.IX Subsection "aiff"
Audio Interchange File Format muxer.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
It accepts the following options:
.IP "\fBwrite_id3v2\fR" 4
.IX Item "write_id3v2"
Enable ID3v2 tags writing when set to 1. Default is 0 (disabled).
.IP "\fBid3v2_version\fR" 4
.IX Item "id3v2_version"
Select ID3v2 version to write. Currently only version 3 and 4 (aka.
ID3v2.3 and ID3v2.4) are supported. The default is version 4.
.SS "asf"
.IX Subsection "asf"
Advanced Systems Format muxer.
.PP
Note that Windows Media Audio (wma) and Windows Media Video (wmv) use this
muxer too.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
It accepts the following options:
.IP "\fBpacket_size\fR" 4
.IX Item "packet_size"
Set the muxer packet size. By tuning this setting you may reduce data
fragmentation or muxer overhead depending on your source. Default value is
3200, minimum is 100, maximum is 64k.
.SS "chromaprint"
.IX Subsection "chromaprint"
Chromaprint fingerprinter
.PP
This muxer feeds audio data to the Chromaprint library, which generates
a fingerprint for the provided audio data. It takes a single signed
native-endian 16\-bit raw audio stream.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBsilence_threshold\fR" 4
.IX Item "silence_threshold"
Threshold for detecting silence, ranges from 0 to 32767. \-1 for default
(required for use with the AcoustID service).
.IP "\fBalgorithm\fR" 4
.IX Item "algorithm"
Algorithm index to fingerprint with.
.IP "\fBfp_format\fR" 4
.IX Item "fp_format"
Format to output the fingerprint as. Accepts the following options:
.RS 4
.IP "\fBraw\fR" 4
.IX Item "raw"
Binary raw fingerprint
.IP "\fBcompressed\fR" 4
.IX Item "compressed"
Binary compressed fingerprint
.IP "\fBbase64\fR" 4
.IX Item "base64"
Base64 compressed fingerprint
.RE
.RS 4
.RE
.SS "crc"
.IX Subsection "crc"
\&\s-1CRC \s0(Cyclic Redundancy Check) testing format.
.PP
This muxer computes and prints the Adler\-32 \s-1CRC\s0 of all the input audio
and video frames. By default audio frames are converted to signed
16\-bit raw audio and video frames to raw video before computing the
\&\s-1CRC.\s0
.PP
The output of the muxer consists of a single line of the form:
CRC=0x\fI\s-1CRC\s0\fR, where \fI\s-1CRC\s0\fR is a hexadecimal number 0\-padded to
8 digits containing the \s-1CRC\s0 for all the decoded input frames.
.PP
See also the \fBframecrc\fR muxer.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
For example to compute the \s-1CRC\s0 of the input, and store it in the file
\&\fIout.crc\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f crc out.crc
.Ve
.PP
You can print the \s-1CRC\s0 to stdout with the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f crc \-
.Ve
.PP
You can select the output format of each frame with \fBffmpeg\fR by
specifying the audio and video codec and format. For example to
compute the \s-1CRC\s0 of the input audio converted to \s-1PCM\s0 unsigned 8\-bit
and the input video converted to \s-1MPEG\-2\s0 video, use the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-c:a pcm_u8 \-c:v mpeg2video \-f crc \-
.Ve
.SS "flv"
.IX Subsection "flv"
Adobe Flash Video Format muxer.
.PP
This muxer accepts the following options:
.IP "\fBflvflags\fR \fIflags\fR" 4
.IX Item "flvflags flags"
Possible values:
.RS 4
.IP "\fBaac_seq_header_detect\fR" 4
.IX Item "aac_seq_header_detect"
Place \s-1AAC\s0 sequence header based on audio stream data.
.IP "\fBno_sequence_end\fR" 4
.IX Item "no_sequence_end"
Disable sequence end tag.
.RE
.RS 4
.RE
.SS "framecrc"
.IX Subsection "framecrc"
Per-packet \s-1CRC \s0(Cyclic Redundancy Check) testing format.
.PP
This muxer computes and prints the Adler\-32 \s-1CRC\s0 for each audio
and video packet. By default audio frames are converted to signed
16\-bit raw audio and video frames to raw video before computing the
\&\s-1CRC.\s0
.PP
The output of the muxer consists of a line for each audio and video
packet of the form:
.PP
.Vb 1
\&        <stream_index>, <packet_dts>, <packet_pts>, <packet_duration>, <packet_size>, 0x<CRC>
.Ve
.PP
\&\fI\s-1CRC\s0\fR is a hexadecimal number 0\-padded to 8 digits containing the
\&\s-1CRC\s0 of the packet.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
For example to compute the \s-1CRC\s0 of the audio and video frames in
\&\fI\s-1INPUT\s0\fR, converted to raw audio and video packets, and store it
in the file \fIout.crc\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framecrc out.crc
.Ve
.PP
To print the information to stdout, use the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framecrc \-
.Ve
.PP
With \fBffmpeg\fR, you can select the output format to which the
audio and video frames are encoded before computing the \s-1CRC\s0 for each
packet by specifying the audio and video codec. For example, to
compute the \s-1CRC\s0 of each decoded input audio frame converted to \s-1PCM\s0
unsigned 8\-bit and of each decoded input video frame converted to
\&\s-1MPEG\-2\s0 video, use the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-c:a pcm_u8 \-c:v mpeg2video \-f framecrc \-
.Ve
.PP
See also the \fBcrc\fR muxer.
.SS "framehash"
.IX Subsection "framehash"
Per-packet hash testing format.
.PP
This muxer computes and prints a cryptographic hash for each audio
and video packet. This can be used for packet-by-packet equality
checks without having to individually do a binary comparison on each.
.PP
By default audio frames are converted to signed 16\-bit raw audio and
video frames to raw video before computing the hash, but the output
of explicit conversions to other codecs can also be used. It uses the
\&\s-1SHA\-256\s0 cryptographic hash function by default, but supports several
other algorithms.
.PP
The output of the muxer consists of a line for each audio and video
packet of the form:
.PP
.Vb 1
\&        <stream_index>, <packet_dts>, <packet_pts>, <packet_duration>, <packet_size>, <hash>
.Ve
.PP
\&\fIhash\fR is a hexadecimal number representing the computed hash
for the packet.
.IP "\fBhash\fR \fIalgorithm\fR" 4
.IX Item "hash algorithm"
Use the cryptographic hash function specified by the string \fIalgorithm\fR.
Supported values include \f(CW\*(C`MD5\*(C'\fR, \f(CW\*(C`murmur3\*(C'\fR, \f(CW\*(C`RIPEMD128\*(C'\fR,
\&\f(CW\*(C`RIPEMD160\*(C'\fR, \f(CW\*(C`RIPEMD256\*(C'\fR, \f(CW\*(C`RIPEMD320\*(C'\fR, \f(CW\*(C`SHA160\*(C'\fR,
\&\f(CW\*(C`SHA224\*(C'\fR, \f(CW\*(C`SHA256\*(C'\fR (default), \f(CW\*(C`SHA512/224\*(C'\fR, \f(CW\*(C`SHA512/256\*(C'\fR,
\&\f(CW\*(C`SHA384\*(C'\fR, \f(CW\*(C`SHA512\*(C'\fR, \f(CW\*(C`CRC32\*(C'\fR and \f(CW\*(C`adler32\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
To compute the \s-1SHA\-256\s0 hash of the audio and video frames in \fI\s-1INPUT\s0\fR,
converted to raw audio and video packets, and store it in the file
\&\fIout.sha256\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framehash out.sha256
.Ve
.PP
To print the information to stdout, using the \s-1MD5\s0 hash function, use
the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framehash \-hash md5 \-
.Ve
.PP
See also the \fBhash\fR muxer.
.SS "framemd5"
.IX Subsection "framemd5"
Per-packet \s-1MD5\s0 testing format.
.PP
This is a variant of the \fBframehash\fR muxer. Unlike that muxer,
it defaults to using the \s-1MD5\s0 hash function.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
To compute the \s-1MD5\s0 hash of the audio and video frames in \fI\s-1INPUT\s0\fR,
converted to raw audio and video packets, and store it in the file
\&\fIout.md5\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framemd5 out.md5
.Ve
.PP
To print the information to stdout, use the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framemd5 \-
.Ve
.PP
See also the \fBframehash\fR and \fBmd5\fR muxers.
.SS "gif"
.IX Subsection "gif"
Animated \s-1GIF\s0 muxer.
.PP
It accepts the following options:
.IP "\fBloop\fR" 4
.IX Item "loop"
Set the number of times to loop the output. Use \f(CW\*(C`\-1\*(C'\fR for no loop, \f(CW0\fR
for looping indefinitely (default).
.IP "\fBfinal_delay\fR" 4
.IX Item "final_delay"
Force the delay (expressed in centiseconds) after the last frame. Each frame
ends with a delay until the next frame. The default is \f(CW\*(C`\-1\*(C'\fR, which is a
special value to tell the muxer to re-use the previous delay. In case of a
loop, you might want to customize this value to mark a pause for instance.
.PP
For example, to encode a gif looping 10 times, with a 5 seconds delay between
the loops:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-loop 10 \-final_delay 500 out.gif
.Ve
.PP
Note 1: if you wish to extract the frames into separate \s-1GIF\s0 files, you need to
force the \fBimage2\fR muxer:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-c:v gif \-f image2 "out%d.gif"
.Ve
.PP
Note 2: the \s-1GIF\s0 format has a very large time base: the delay between two frames
can therefore not be smaller than one centi second.
.SS "hash"
.IX Subsection "hash"
Hash testing format.
.PP
This muxer computes and prints a cryptographic hash of all the input
audio and video frames. This can be used for equality checks without
having to do a complete binary comparison.
.PP
By default audio frames are converted to signed 16\-bit raw audio and
video frames to raw video before computing the hash, but the output
of explicit conversions to other codecs can also be used. Timestamps
are ignored. It uses the \s-1SHA\-256\s0 cryptographic hash function by default,
but supports several other algorithms.
.PP
The output of the muxer consists of a single line of the form:
\&\fIalgo\fR=\fIhash\fR, where \fIalgo\fR is a short string representing
the hash function used, and \fIhash\fR is a hexadecimal number
representing the computed hash.
.IP "\fBhash\fR \fIalgorithm\fR" 4
.IX Item "hash algorithm"
Use the cryptographic hash function specified by the string \fIalgorithm\fR.
Supported values include \f(CW\*(C`MD5\*(C'\fR, \f(CW\*(C`murmur3\*(C'\fR, \f(CW\*(C`RIPEMD128\*(C'\fR,
\&\f(CW\*(C`RIPEMD160\*(C'\fR, \f(CW\*(C`RIPEMD256\*(C'\fR, \f(CW\*(C`RIPEMD320\*(C'\fR, \f(CW\*(C`SHA160\*(C'\fR,
\&\f(CW\*(C`SHA224\*(C'\fR, \f(CW\*(C`SHA256\*(C'\fR (default), \f(CW\*(C`SHA512/224\*(C'\fR, \f(CW\*(C`SHA512/256\*(C'\fR,
\&\f(CW\*(C`SHA384\*(C'\fR, \f(CW\*(C`SHA512\*(C'\fR, \f(CW\*(C`CRC32\*(C'\fR and \f(CW\*(C`adler32\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
To compute the \s-1SHA\-256\s0 hash of the input converted to raw audio and
video, and store it in the file \fIout.sha256\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f hash out.sha256
.Ve
.PP
To print an \s-1MD5\s0 hash to stdout use the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f hash \-hash md5 \-
.Ve
.PP
See also the \fBframehash\fR muxer.
.SS "hls"
.IX Subsection "hls"
Apple \s-1HTTP\s0 Live Streaming muxer that segments MPEG-TS according to
the \s-1HTTP\s0 Live Streaming (\s-1HLS\s0) specification.
.PP
It creates a playlist file, and one or more segment files. The output filename
specifies the playlist filename.
.PP
By default, the muxer creates a file for each segment produced. These files
have the same name as the playlist, followed by a sequential number and a
\&.ts extension.
.PP
For example, to convert an input file with \fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-i in.nut out.m3u8
.Ve
.PP
This example will produce the playlist, \fIout.m3u8\fR, and segment files:
\&\fIout0.ts\fR, \fIout1.ts\fR, \fIout2.ts\fR, etc.
.PP
See also the \fBsegment\fR muxer, which provides a more generic and
flexible implementation of a segmenter, and can be used to perform \s-1HLS\s0
segmentation.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
This muxer supports the following options:
.IP "\fBhls_init_time\fR \fIseconds\fR" 4
.IX Item "hls_init_time seconds"
Set the initial target segment length in seconds. Default value is \fI0\fR.
Segment will be cut on the next key frame after this time has passed on the first m3u8 list.
After the initial playlist is filled \fBffmpeg\fR will cut segments
at duration equal to \f(CW\*(C`hls_time\*(C'\fR
.IP "\fBhls_time\fR \fIseconds\fR" 4
.IX Item "hls_time seconds"
Set the target segment length in seconds. Default value is 2.
Segment will be cut on the next key frame after this time has passed.
.IP "\fBhls_list_size\fR \fIsize\fR" 4
.IX Item "hls_list_size size"
Set the maximum number of playlist entries. If set to 0 the list file
will contain all the segments. Default value is 5.
.IP "\fBhls_ts_options\fR \fIoptions_list\fR" 4
.IX Item "hls_ts_options options_list"
Set output format options using a :\-separated list of key=value
parameters. Values containing \f(CW\*(C`:\*(C'\fR special characters must be
escaped.
.IP "\fBhls_wrap\fR \fIwrap\fR" 4
.IX Item "hls_wrap wrap"
Set the number after which the segment filename number (the number
specified in each segment file) wraps. If set to 0 the number will be
never wrapped. Default value is 0.
.Sp
This option is useful to avoid to fill the disk with many segment
files, and limits the maximum number of segment files written to disk
to \fIwrap\fR.
.IP "\fBstart_number\fR \fInumber\fR" 4
.IX Item "start_number number"
Start the playlist sequence number from \fInumber\fR. Default value is
0.
.IP "\fBhls_allow_cache\fR \fIallowcache\fR" 4
.IX Item "hls_allow_cache allowcache"
Explicitly set whether the client \s-1MAY \\fIs0\fR\|(1) or \s-1MUST NOT \\fIs0\fR\|(0) cache media segments.
.IP "\fBhls_base_url\fR \fIbaseurl\fR" 4
.IX Item "hls_base_url baseurl"
Append \fIbaseurl\fR to every entry in the playlist.
Useful to generate playlists with absolute paths.
.Sp
Note that the playlist sequence number must be unique for each segment
and it is not to be confused with the segment filename sequence number
which can be cyclic, for example if the \fBwrap\fR option is
specified.
.IP "\fBhls_segment_filename\fR \fIfilename\fR" 4
.IX Item "hls_segment_filename filename"
Set the segment filename. Unless \f(CW\*(C`hls_flags single_file\*(C'\fR is set,
\&\fIfilename\fR is used as a string format with the segment number:
.Sp
.Vb 1
\&        ffmpeg \-i in.nut \-hls_segment_filename \*(Aqfile%03d.ts\*(Aq out.m3u8
.Ve
.Sp
This example will produce the playlist, \fIout.m3u8\fR, and segment files:
\&\fIfile000.ts\fR, \fIfile001.ts\fR, \fIfile002.ts\fR, etc.
.IP "\fBuse_localtime\fR" 4
.IX Item "use_localtime"
Use strftime on \fIfilename\fR to expand the segment filename with localtime.
The segment number (%d) is not available in this mode.
.Sp
.Vb 1
\&        ffmpeg \-i in.nut \-use_localtime 1 \-hls_segment_filename \*(Aqfile\-%Y%m%d\-%s.ts\*(Aq out.m3u8
.Ve
.Sp
This example will produce the playlist, \fIout.m3u8\fR, and segment files:
\&\fIfile\-20160215\-1455569023.ts\fR, \fIfile\-20160215\-1455569024.ts\fR, etc.
.IP "\fBuse_localtime_mkdir\fR" 4
.IX Item "use_localtime_mkdir"
Used together with \-use_localtime, it will create up to one subdirectory which
is expanded in \fIfilename\fR.
.Sp
.Vb 1
\&        ffmpeg \-i in.nut \-use_localtime 1 \-use_localtime_mkdir 1 \-hls_segment_filename \*(Aq%Y%m%d/file\-%Y%m%d\-%s.ts\*(Aq out.m3u8
.Ve
.Sp
This example will create a directory 201560215 (if it does not exist), and then
produce the playlist, \fIout.m3u8\fR, and segment files:
\&\fI201560215/file\-20160215\-1455569023.ts\fR, \fI201560215/file\-20160215\-1455569024.ts\fR, etc.
.IP "\fBhls_key_info_file\fR \fIkey_info_file\fR" 4
.IX Item "hls_key_info_file key_info_file"
Use the information in \fIkey_info_file\fR for segment encryption. The first
line of \fIkey_info_file\fR specifies the key \s-1URI\s0 written to the playlist. The
key \s-1URL\s0 is used to access the encryption key during playback. The second line
specifies the path to the key file used to obtain the key during the encryption
process. The key file is read as a single packed array of 16 octets in binary
format. The optional third line specifies the initialization vector (\s-1IV\s0) as a
hexadecimal string to be used instead of the segment sequence number (default)
for encryption. Changes to \fIkey_info_file\fR will result in segment
encryption with the new key/IV and an entry in the playlist for the new key
\&\s-1URI/IV.\s0
.Sp
Key info file format:
.Sp
.Vb 3
\&        <key URI>
\&        <key file path>
\&        <IV> (optional)
.Ve
.Sp
Example key URIs:
.Sp
.Vb 3
\&        http://server/file.key
\&        /path/to/file.key
\&        file.key
.Ve
.Sp
Example key file paths:
.Sp
.Vb 2
\&        file.key
\&        /path/to/file.key
.Ve
.Sp
Example \s-1IV:\s0
.Sp
.Vb 1
\&        0123456789ABCDEF0123456789ABCDEF
.Ve
.Sp
Key info file example:
.Sp
.Vb 3
\&        http://server/file.key
\&        /path/to/file.key
\&        0123456789ABCDEF0123456789ABCDEF
.Ve
.Sp
Example shell script:
.Sp
.Vb 8
\&        #!/bin/sh
\&        BASE_URL=${1:\-\*(Aq.\*(Aq}
\&        openssl rand 16 > file.key
\&        echo $BASE_URL/file.key > file.keyinfo
\&        echo file.key >> file.keyinfo
\&        echo $(openssl rand \-hex 16) >> file.keyinfo
\&        ffmpeg \-f lavfi \-re \-i testsrc \-c:v h264 \-hls_flags delete_segments \e
\&          \-hls_key_info_file file.keyinfo out.m3u8
.Ve
.IP "\fBhls_flags single_file\fR" 4
.IX Item "hls_flags single_file"
If this flag is set, the muxer will store all segments in a single MPEG-TS
file, and will use byte ranges in the playlist. \s-1HLS\s0 playlists generated with
this way will have the version number 4.
For example:
.Sp
.Vb 1
\&        ffmpeg \-i in.nut \-hls_flags single_file out.m3u8
.Ve
.Sp
Will produce the playlist, \fIout.m3u8\fR, and a single segment file,
\&\fIout.ts\fR.
.IP "\fBhls_flags delete_segments\fR" 4
.IX Item "hls_flags delete_segments"
Segment files removed from the playlist are deleted after a period of time
equal to the duration of the segment plus the duration of the playlist.
.IP "\fBhls_flags append_list\fR" 4
.IX Item "hls_flags append_list"
Append new segments into the end of old segment list,
and remove the \f(CW\*(C`#EXT\-X\-ENDLIST\*(C'\fR from the old segment list.
.IP "\fBhls_flags round_durations\fR" 4
.IX Item "hls_flags round_durations"
Round the duration info in the playlist file segment info to integer
values, instead of using floating point.
.IP "\fBhls_flags discont_starts\fR" 4
.IX Item "hls_flags discont_starts"
Add the \f(CW\*(C`#EXT\-X\-DISCONTINUITY\*(C'\fR tag to the playlist, before the
first segment's information.
.IP "\fBhls_flags omit_endlist\fR" 4
.IX Item "hls_flags omit_endlist"
Do not append the \f(CW\*(C`EXT\-X\-ENDLIST\*(C'\fR tag at the end of the playlist.
.IP "\fBhls_flags split_by_time\fR" 4
.IX Item "hls_flags split_by_time"
Allow segments to start on frames other than keyframes. This improves
behavior on some players when the time between keyframes is inconsistent,
but may make things worse on others, and can cause some oddities during
seeking. This flag should be used with the \f(CW\*(C`hls_time\*(C'\fR option.
.IP "\fBhls_flags program_date_time\fR" 4
.IX Item "hls_flags program_date_time"
Generate \f(CW\*(C`EXT\-X\-PROGRAM\-DATE\-TIME\*(C'\fR tags.
.IP "\fBhls_playlist_type event\fR" 4
.IX Item "hls_playlist_type event"
Emit \f(CW\*(C`#EXT\-X\-PLAYLIST\-TYPE:EVENT\*(C'\fR in the m3u8 header. Forces
\&\fBhls_list_size\fR to 0; the playlist can only be appended to.
.IP "\fBhls_playlist_type vod\fR" 4
.IX Item "hls_playlist_type vod"
Emit \f(CW\*(C`#EXT\-X\-PLAYLIST\-TYPE:VOD\*(C'\fR in the m3u8 header. Forces
\&\fBhls_list_size\fR to 0; the playlist must not change.
.IP "\fBmethod\fR" 4
.IX Item "method"
Use the given \s-1HTTP\s0 method to create the hls files.
.Sp
.Vb 1
\&        ffmpeg \-re \-i in.ts \-f hls \-method PUT http://example.com/live/out.m3u8
.Ve
.Sp
This example will upload all the mpegts segment files to the \s-1HTTP\s0
server using the \s-1HTTP PUT\s0 method, and update the m3u8 files every
\&\f(CW\*(C`refresh\*(C'\fR times using the same method.
Note that the \s-1HTTP\s0 server must support the given method for uploading
files.
.SS "ico"
.IX Subsection "ico"
\&\s-1ICO\s0 file muxer.
.PP
Microsoft's icon file format (\s-1ICO\s0) has some strict limitations that should be noted:
.IP "\(bu" 4
Size cannot exceed 256 pixels in any dimension
.IP "\(bu" 4
Only \s-1BMP\s0 and \s-1PNG\s0 images can be stored
.IP "\(bu" 4
If a \s-1BMP\s0 image is used, it must be one of the following pixel formats:
.Sp
.Vb 7
\&        BMP Bit Depth      FFmpeg Pixel Format
\&        1bit               pal8
\&        4bit               pal8
\&        8bit               pal8
\&        16bit              rgb555le
\&        24bit              bgr24
\&        32bit              bgra
.Ve
.IP "\(bu" 4
If a \s-1BMP\s0 image is used, it must use the \s-1BITMAPINFOHEADER DIB\s0 header
.IP "\(bu" 4
If a \s-1PNG\s0 image is used, it must use the rgba pixel format
.SS "image2"
.IX Subsection "image2"
Image file muxer.
.PP
The image file muxer writes video frames to image files.
.PP
The output filenames are specified by a pattern, which can be used to
produce sequentially numbered series of files.
The pattern may contain the string \*(L"%d\*(R" or "%0\fIN\fRd\*(L", this string
specifies the position of the characters representing a numbering in
the filenames. If the form \*(R"%0\fIN\fRd" is used, the string
representing the number in each filename is 0\-padded to \fIN\fR
digits. The literal character '%' can be specified in the pattern with
the string \*(L"%%\*(R".
.PP
If the pattern contains \*(L"%d\*(R" or "%0\fIN\fRd", the first filename of
the file list specified will contain the number 1, all the following
numbers will be sequential.
.PP
The pattern may contain a suffix which is used to automatically
determine the format of the image files to write.
.PP
For example the pattern \*(L"img\-%03d.bmp\*(R" will specify a sequence of
filenames of the form \fIimg\-001.bmp\fR, \fIimg\-002.bmp\fR, ...,
\&\fIimg\-010.bmp\fR, etc.
The pattern \*(L"img%%\-%d.jpg\*(R" will specify a sequence of filenames of the
form \fIimg%\-1.jpg\fR, \fIimg%\-2.jpg\fR, ..., \fIimg%\-10.jpg\fR,
etc.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
The following example shows how to use \fBffmpeg\fR for creating a
sequence of files \fIimg\-001.jpeg\fR, \fIimg\-002.jpeg\fR, ...,
taking one image every second from the input video:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-vsync 1 \-r 1 \-f image2 \*(Aqimg\-%03d.jpeg\*(Aq
.Ve
.PP
Note that with \fBffmpeg\fR, if the format is not specified with the
\&\f(CW\*(C`\-f\*(C'\fR option and the output filename specifies an image file
format, the image2 muxer is automatically selected, so the previous
command can be written as:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-vsync 1 \-r 1 \*(Aqimg\-%03d.jpeg\*(Aq
.Ve
.PP
Note also that the pattern must not necessarily contain \*(L"%d\*(R" or
"%0\fIN\fRd", for example to create a single image file
\&\fIimg.jpeg\fR from the input video you can employ the command:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-f image2 \-frames:v 1 img.jpeg
.Ve
.PP
The \fBstrftime\fR option allows you to expand the filename with
date and time information. Check the documentation of
the \f(CW\*(C`strftime()\*(C'\fR function for the syntax.
.PP
For example to generate image files from the \f(CW\*(C`strftime()\*(C'\fR
\&\*(L"%Y\-%m\-%d_%H\-%M\-%S\*(R" pattern, the following \fBffmpeg\fR command
can be used:
.PP
.Vb 1
\&        ffmpeg \-f v4l2 \-r 1 \-i /dev/video0 \-f image2 \-strftime 1 "%Y\-%m\-%d_%H\-%M\-%S.jpg"
.Ve
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBstart_number\fR" 4
.IX Item "start_number"
Start the sequence from the specified number. Default value is 0.
.IP "\fBupdate\fR" 4
.IX Item "update"
If set to 1, the filename will always be interpreted as just a
filename, not a pattern, and the corresponding file will be continuously
overwritten with new images. Default value is 0.
.IP "\fBstrftime\fR" 4
.IX Item "strftime"
If set to 1, expand the filename with date and time information from
\&\f(CW\*(C`strftime()\*(C'\fR. Default value is 0.
.PP
The image muxer supports the .Y.U.V image file format. This format is
special in that that each image frame consists of three files, for
each of the \s-1YUV420P\s0 components. To read or write this image file format,
specify the name of the '.Y' file. The muxer will automatically open the
\&'.U' and '.V' files as required.
.SS "matroska"
.IX Subsection "matroska"
Matroska container muxer.
.PP
This muxer implements the matroska and webm container specs.
.PP
\fIMetadata\fR
.IX Subsection "Metadata"
.PP
The recognized metadata settings in this muxer are:
.IP "\fBtitle\fR" 4
.IX Item "title"
Set title name provided to a single track.
.IP "\fBlanguage\fR" 4
.IX Item "language"
Specify the language of the track in the Matroska languages form.
.Sp
The language can be either the 3 letters bibliographic \s-1ISO\-639\-2 \s0(\s-1ISO
639\-2/B\s0) form (like \*(L"fre\*(R" for French), or a language code mixed with a
country code for specialities in languages (like \*(L"fre-ca\*(R" for Canadian
French).
.IP "\fBstereo_mode\fR" 4
.IX Item "stereo_mode"
Set stereo 3D video layout of two views in a single video track.
.Sp
The following values are recognized:
.RS 4
.IP "\fBmono\fR" 4
.IX Item "mono"
video is not stereo
.IP "\fBleft_right\fR" 4
.IX Item "left_right"
Both views are arranged side by side, Left-eye view is on the left
.IP "\fBbottom_top\fR" 4
.IX Item "bottom_top"
Both views are arranged in top-bottom orientation, Left-eye view is at bottom
.IP "\fBtop_bottom\fR" 4
.IX Item "top_bottom"
Both views are arranged in top-bottom orientation, Left-eye view is on top
.IP "\fBcheckerboard_rl\fR" 4
.IX Item "checkerboard_rl"
Each view is arranged in a checkerboard interleaved pattern, Left-eye view being first
.IP "\fBcheckerboard_lr\fR" 4
.IX Item "checkerboard_lr"
Each view is arranged in a checkerboard interleaved pattern, Right-eye view being first
.IP "\fBrow_interleaved_rl\fR" 4
.IX Item "row_interleaved_rl"
Each view is constituted by a row based interleaving, Right-eye view is first row
.IP "\fBrow_interleaved_lr\fR" 4
.IX Item "row_interleaved_lr"
Each view is constituted by a row based interleaving, Left-eye view is first row
.IP "\fBcol_interleaved_rl\fR" 4
.IX Item "col_interleaved_rl"
Both views are arranged in a column based interleaving manner, Right-eye view is first column
.IP "\fBcol_interleaved_lr\fR" 4
.IX Item "col_interleaved_lr"
Both views are arranged in a column based interleaving manner, Left-eye view is first column
.IP "\fBanaglyph_cyan_red\fR" 4
.IX Item "anaglyph_cyan_red"
All frames are in anaglyph format viewable through red-cyan filters
.IP "\fBright_left\fR" 4
.IX Item "right_left"
Both views are arranged side by side, Right-eye view is on the left
.IP "\fBanaglyph_green_magenta\fR" 4
.IX Item "anaglyph_green_magenta"
All frames are in anaglyph format viewable through green-magenta filters
.IP "\fBblock_lr\fR" 4
.IX Item "block_lr"
Both eyes laced in one Block, Left-eye view is first
.IP "\fBblock_rl\fR" 4
.IX Item "block_rl"
Both eyes laced in one Block, Right-eye view is first
.RE
.RS 4
.RE
.PP
For example a 3D WebM clip can be created using the following command line:
.PP
.Vb 1
\&        ffmpeg \-i sample_left_right_clip.mpg \-an \-c:v libvpx \-metadata stereo_mode=left_right \-y stereo_clip.webm
.Ve
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
This muxer supports the following options:
.IP "\fBreserve_index_space\fR" 4
.IX Item "reserve_index_space"
By default, this muxer writes the index for seeking (called cues in Matroska
terms) at the end of the file, because it cannot know in advance how much space
to leave for the index at the beginning of the file. However for some use cases
\&\*(-- e.g.  streaming where seeking is possible but slow \*(-- it is useful to put the
index at the beginning of the file.
.Sp
If this option is set to a non-zero value, the muxer will reserve a given amount
of space in the file header and then try to write the cues there when the muxing
finishes. If the available space does not suffice, muxing will fail. A safe size
for most use cases should be about 50kB per hour of video.
.Sp
Note that cues are only written if the output is seekable and this option will
have no effect if it is not.
.SS "md5"
.IX Subsection "md5"
\&\s-1MD5\s0 testing format.
.PP
This is a variant of the \fBhash\fR muxer. Unlike that muxer, it
defaults to using the \s-1MD5\s0 hash function.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
To compute the \s-1MD5\s0 hash of the input converted to raw
audio and video, and store it in the file \fIout.md5\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f md5 out.md5
.Ve
.PP
You can print the \s-1MD5\s0 to stdout with the command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f md5 \-
.Ve
.PP
See also the \fBhash\fR and \fBframemd5\fR muxers.
.SS "mov, mp4, ismv"
.IX Subsection "mov, mp4, ismv"
\&\s-1MOV/MP4/ISMV \s0(Smooth Streaming) muxer.
.PP
The mov/mp4/ismv muxer supports fragmentation. Normally, a \s-1MOV/MP4\s0
file has all the metadata about all packets stored in one location
(written at the end of the file, it can be moved to the start for
better playback by adding \fIfaststart\fR to the \fImovflags\fR, or
using the \fBqt-faststart\fR tool). A fragmented
file consists of a number of fragments, where packets and metadata
about these packets are stored together. Writing a fragmented
file has the advantage that the file is decodable even if the
writing is interrupted (while a normal \s-1MOV/MP4\s0 is undecodable if
it is not properly finished), and it requires less memory when writing
very long files (since writing normal \s-1MOV/MP4\s0 files stores info about
every single packet in memory until the file is closed). The downside
is that it is less compatible with other applications.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Fragmentation is enabled by setting one of the AVOptions that define
how to cut the file into fragments:
.IP "\fB\-moov_size\fR \fIbytes\fR" 4
.IX Item "-moov_size bytes"
Reserves space for the moov atom at the beginning of the file instead of placing the
moov atom at the end. If the space reserved is insufficient, muxing will fail.
.IP "\fB\-movflags frag_keyframe\fR" 4
.IX Item "-movflags frag_keyframe"
Start a new fragment at each video keyframe.
.IP "\fB\-frag_duration\fR \fIduration\fR" 4
.IX Item "-frag_duration duration"
Create fragments that are \fIduration\fR microseconds long.
.IP "\fB\-frag_size\fR \fIsize\fR" 4
.IX Item "-frag_size size"
Create fragments that contain up to \fIsize\fR bytes of payload data.
.IP "\fB\-movflags frag_custom\fR" 4
.IX Item "-movflags frag_custom"
Allow the caller to manually choose when to cut fragments, by
calling \f(CW\*(C`av_write_frame(ctx, NULL)\*(C'\fR to write a fragment with
the packets written so far. (This is only useful with other
applications integrating libavformat, not from \fBffmpeg\fR.)
.IP "\fB\-min_frag_duration\fR \fIduration\fR" 4
.IX Item "-min_frag_duration duration"
Don't create fragments that are shorter than \fIduration\fR microseconds long.
.PP
If more than one condition is specified, fragments are cut when
one of the specified conditions is fulfilled. The exception to this is
\&\f(CW\*(C`\-min_frag_duration\*(C'\fR, which has to be fulfilled for any of the other
conditions to apply.
.PP
Additionally, the way the output file is written can be adjusted
through a few other options:
.IP "\fB\-movflags empty_moov\fR" 4
.IX Item "-movflags empty_moov"
Write an initial moov atom directly at the start of the file, without
describing any samples in it. Generally, an mdat/moov pair is written
at the start of the file, as a normal \s-1MOV/MP4\s0 file, containing only
a short portion of the file. With this option set, there is no initial
mdat atom, and the moov atom only describes the tracks but has
a zero duration.
.Sp
This option is implicitly set when writing ismv (Smooth Streaming) files.
.IP "\fB\-movflags separate_moof\fR" 4
.IX Item "-movflags separate_moof"
Write a separate moof (movie fragment) atom for each track. Normally,
packets for all tracks are written in a moof atom (which is slightly
more efficient), but with this option set, the muxer writes one moof/mdat
pair for each track, making it easier to separate tracks.
.Sp
This option is implicitly set when writing ismv (Smooth Streaming) files.
.IP "\fB\-movflags faststart\fR" 4
.IX Item "-movflags faststart"
Run a second pass moving the index (moov atom) to the beginning of the file.
This operation can take a while, and will not work in various situations such
as fragmented output, thus it is not enabled by default.
.IP "\fB\-movflags rtphint\fR" 4
.IX Item "-movflags rtphint"
Add \s-1RTP\s0 hinting tracks to the output file.
.IP "\fB\-movflags disable_chpl\fR" 4
.IX Item "-movflags disable_chpl"
Disable Nero chapter markers (chpl atom).  Normally, both Nero chapters
and a QuickTime chapter track are written to the file. With this option
set, only the QuickTime chapter track will be written. Nero chapters can
cause failures when the file is reprocessed with certain tagging programs, like
mp3Tag 2.61a and iTunes 11.3, most likely other versions are affected as well.
.IP "\fB\-movflags omit_tfhd_offset\fR" 4
.IX Item "-movflags omit_tfhd_offset"
Do not write any absolute base_data_offset in tfhd atoms. This avoids
tying fragments to absolute byte positions in the file/streams.
.IP "\fB\-movflags default_base_moof\fR" 4
.IX Item "-movflags default_base_moof"
Similarly to the omit_tfhd_offset, this flag avoids writing the
absolute base_data_offset field in tfhd atoms, but does so by using
the new default-base-is-moof flag instead. This flag is new from
14496\-12:2012. This may make the fragments easier to parse in certain
circumstances (avoiding basing track fragment location calculations
on the implicit end of the previous track fragment).
.IP "\fB\-write_tmcd\fR" 4
.IX Item "-write_tmcd"
Specify \f(CW\*(C`on\*(C'\fR to force writing a timecode track, \f(CW\*(C`off\*(C'\fR to disable it
and \f(CW\*(C`auto\*(C'\fR to write a timecode track only for mov and mp4 output (default).
.PP
\fIExample\fR
.IX Subsection "Example"
.PP
Smooth Streaming content can be pushed in real time to a publishing
point on \s-1IIS\s0 with this muxer. Example:
.PP
.Vb 1
\&        ffmpeg \-re <<normal input/transcoding options>> \-movflags isml+frag_keyframe \-f ismv http://server/publishingpoint.isml/Streams(Encoder1)
.Ve
.PP
\fIAudible \s-1AAX\s0\fR
.IX Subsection "Audible AAX"
.PP
Audible \s-1AAX\s0 files are encrypted M4B files, and they can be decrypted by specifying a 4 byte activation secret.
.PP
.Vb 1
\&        ffmpeg \-activation_bytes 1CEB00DA \-i test.aax \-vn \-c:a copy output.mp4
.Ve
.SS "mp3"
.IX Subsection "mp3"
The \s-1MP3\s0 muxer writes a raw \s-1MP3\s0 stream with the following optional features:
.IP "\(bu" 4
An ID3v2 metadata header at the beginning (enabled by default). Versions 2.3 and
2.4 are supported, the \f(CW\*(C`id3v2_version\*(C'\fR private option controls which one is
used (3 or 4). Setting \f(CW\*(C`id3v2_version\*(C'\fR to 0 disables the ID3v2 header
completely.
.Sp
The muxer supports writing attached pictures (\s-1APIC\s0 frames) to the ID3v2 header.
The pictures are supplied to the muxer in form of a video stream with a single
packet. There can be any number of those streams, each will correspond to a
single \s-1APIC\s0 frame.  The stream metadata tags \fItitle\fR and \fIcomment\fR map
to \s-1APIC \s0\fIdescription\fR and \fIpicture type\fR respectively. See
<\fBhttp://id3.org/id3v2.4.0\-frames\fR> for allowed picture types.
.Sp
Note that the \s-1APIC\s0 frames must be written at the beginning, so the muxer will
buffer the audio frames until it gets all the pictures. It is therefore advised
to provide the pictures as soon as possible to avoid excessive buffering.
.IP "\(bu" 4
A Xing/LAME frame right after the ID3v2 header (if present). It is enabled by
default, but will be written only if the output is seekable. The
\&\f(CW\*(C`write_xing\*(C'\fR private option can be used to disable it.  The frame contains
various information that may be useful to the decoder, like the audio duration
or encoder delay.
.IP "\(bu" 4
A legacy ID3v1 tag at the end of the file (disabled by default). It may be
enabled with the \f(CW\*(C`write_id3v1\*(C'\fR private option, but as its capabilities are
very limited, its usage is not recommended.
.PP
Examples:
.PP
Write an mp3 with an ID3v2.3 header and an ID3v1 footer:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-id3v2_version 3 \-write_id3v1 1 out.mp3
.Ve
.PP
To attach a picture to an mp3 file select both the audio and the picture stream
with \f(CW\*(C`map\*(C'\fR:
.PP
.Vb 2
\&        ffmpeg \-i input.mp3 \-i cover.png \-c copy \-map 0 \-map 1
\&        \-metadata:s:v title="Album cover" \-metadata:s:v comment="Cover (Front)" out.mp3
.Ve
.PP
Write a \*(L"clean\*(R" \s-1MP3\s0 without any extra features:
.PP
.Vb 1
\&        ffmpeg \-i input.wav \-write_xing 0 \-id3v2_version 0 out.mp3
.Ve
.SS "mpegts"
.IX Subsection "mpegts"
\&\s-1MPEG\s0 transport stream muxer.
.PP
This muxer implements \s-1ISO 13818\-1\s0 and part of \s-1ETSI EN 300 468.\s0
.PP
The recognized metadata settings in mpegts muxer are \f(CW\*(C`service_provider\*(C'\fR
and \f(CW\*(C`service_name\*(C'\fR. If they are not set the default for
\&\f(CW\*(C`service_provider\*(C'\fR is \*(L"FFmpeg\*(R" and the default for
\&\f(CW\*(C`service_name\*(C'\fR is \*(L"Service01\*(R".
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
The muxer options are:
.IP "\fBmpegts_original_network_id\fR \fInumber\fR" 4
.IX Item "mpegts_original_network_id number"
Set the original_network_id (default 0x0001). This is unique identifier
of a network in \s-1DVB.\s0 Its main use is in the unique identification of a
service through the path Original_Network_ID, Transport_Stream_ID.
.IP "\fBmpegts_transport_stream_id\fR \fInumber\fR" 4
.IX Item "mpegts_transport_stream_id number"
Set the transport_stream_id (default 0x0001). This identifies a
transponder in \s-1DVB.\s0
.IP "\fBmpegts_service_id\fR \fInumber\fR" 4
.IX Item "mpegts_service_id number"
Set the service_id (default 0x0001) also known as program in \s-1DVB.\s0
.IP "\fBmpegts_service_type\fR \fInumber\fR" 4
.IX Item "mpegts_service_type number"
Set the program service_type (default \fIdigital_tv\fR), see below
a list of pre defined values.
.IP "\fBmpegts_pmt_start_pid\fR \fInumber\fR" 4
.IX Item "mpegts_pmt_start_pid number"
Set the first \s-1PID\s0 for \s-1PMT \s0(default 0x1000, max 0x1f00).
.IP "\fBmpegts_start_pid\fR \fInumber\fR" 4
.IX Item "mpegts_start_pid number"
Set the first \s-1PID\s0 for data packets (default 0x0100, max 0x0f00).
.IP "\fBmpegts_m2ts_mode\fR \fInumber\fR" 4
.IX Item "mpegts_m2ts_mode number"
Enable m2ts mode if set to 1. Default value is \-1 which disables m2ts mode.
.IP "\fBmuxrate\fR \fInumber\fR" 4
.IX Item "muxrate number"
Set a constant muxrate (default \s-1VBR\s0).
.IP "\fBpcr_period\fR \fInumer\fR" 4
.IX Item "pcr_period numer"
Override the default \s-1PCR\s0 retransmission time (default 20ms), ignored
if variable muxrate is selected.
.IP "\fBpat_period\fR \fInumber\fR" 4
.IX Item "pat_period number"
Maximal time in seconds between \s-1PAT/PMT\s0 tables.
.IP "\fBsdt_period\fR \fInumber\fR" 4
.IX Item "sdt_period number"
Maximal time in seconds between \s-1SDT\s0 tables.
.IP "\fBpes_payload_size\fR \fInumber\fR" 4
.IX Item "pes_payload_size number"
Set minimum \s-1PES\s0 packet payload in bytes.
.IP "\fBmpegts_flags\fR \fIflags\fR" 4
.IX Item "mpegts_flags flags"
Set flags (see below).
.IP "\fBmpegts_copyts\fR \fInumber\fR" 4
.IX Item "mpegts_copyts number"
Preserve original timestamps, if value is set to 1. Default value is \-1, which
results in shifting timestamps so that they start from 0.
.IP "\fBtables_version\fR \fInumber\fR" 4
.IX Item "tables_version number"
Set \s-1PAT, PMT\s0 and \s-1SDT\s0 version (default 0, valid values are from 0 to 31, inclusively).
This option allows updating stream structure so that standard consumer may
detect the change. To do so, reopen output AVFormatContext (in case of \s-1API\s0
usage) or restart ffmpeg instance, cyclically changing tables_version value:
.Sp
.Vb 7
\&        ffmpeg \-i source1.ts \-codec copy \-f mpegts \-tables_version 0 udp://1.1.1.1:1111
\&        ffmpeg \-i source2.ts \-codec copy \-f mpegts \-tables_version 1 udp://1.1.1.1:1111
\&        ...
\&        ffmpeg \-i source3.ts \-codec copy \-f mpegts \-tables_version 31 udp://1.1.1.1:1111
\&        ffmpeg \-i source1.ts \-codec copy \-f mpegts \-tables_version 0 udp://1.1.1.1:1111
\&        ffmpeg \-i source2.ts \-codec copy \-f mpegts \-tables_version 1 udp://1.1.1.1:1111
\&        ...
.Ve
.PP
Option \fBmpegts_service_type\fR accepts the following values:
.IP "\fBhex_value\fR" 4
.IX Item "hex_value"
Any hexdecimal value between 0x01 to 0xff as defined in \s-1ETSI 300 468.\s0
.IP "\fBdigital_tv\fR" 4
.IX Item "digital_tv"
Digital \s-1TV\s0 service.
.IP "\fBdigital_radio\fR" 4
.IX Item "digital_radio"
Digital Radio service.
.IP "\fBteletext\fR" 4
.IX Item "teletext"
Teletext service.
.IP "\fBadvanced_codec_digital_radio\fR" 4
.IX Item "advanced_codec_digital_radio"
Advanced Codec Digital Radio service.
.IP "\fBmpeg2_digital_hdtv\fR" 4
.IX Item "mpeg2_digital_hdtv"
\&\s-1MPEG2\s0 Digital \s-1HDTV\s0 service.
.IP "\fBadvanced_codec_digital_sdtv\fR" 4
.IX Item "advanced_codec_digital_sdtv"
Advanced Codec Digital \s-1SDTV\s0 service.
.IP "\fBadvanced_codec_digital_hdtv\fR" 4
.IX Item "advanced_codec_digital_hdtv"
Advanced Codec Digital \s-1HDTV\s0 service.
.PP
Option \fBmpegts_flags\fR may take a set of such flags:
.IP "\fBresend_headers\fR" 4
.IX Item "resend_headers"
Reemit \s-1PAT/PMT\s0 before writing the next packet.
.IP "\fBlatm\fR" 4
.IX Item "latm"
Use \s-1LATM\s0 packetization for \s-1AAC.\s0
.IP "\fBpat_pmt_at_frames\fR" 4
.IX Item "pat_pmt_at_frames"
Reemit \s-1PAT\s0 and \s-1PMT\s0 at each video frame.
.IP "\fBsystem_b\fR" 4
.IX Item "system_b"
Conform to System B (\s-1DVB\s0) instead of System A (\s-1ATSC\s0).
.PP
\fIExample\fR
.IX Subsection "Example"
.PP
.Vb 9
\&        ffmpeg \-i file.mpg \-c copy \e
\&             \-mpegts_original_network_id 0x1122 \e
\&             \-mpegts_transport_stream_id 0x3344 \e
\&             \-mpegts_service_id 0x5566 \e
\&             \-mpegts_pmt_start_pid 0x1500 \e
\&             \-mpegts_start_pid 0x150 \e
\&             \-metadata service_provider="Some provider" \e
\&             \-metadata service_name="Some Channel" \e
\&             \-y out.ts
.Ve
.SS "mxf, mxf_d10"
.IX Subsection "mxf, mxf_d10"
\&\s-1MXF\s0 muxer.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
The muxer options are:
.IP "\fBstore_user_comments\fR \fIbool\fR" 4
.IX Item "store_user_comments bool"
Set if user comments should be stored if available or never.
\&\s-1IRT D\-10\s0 does not allow user comments. The default is thus to write them for
mxf but not for mxf_d10
.SS "null"
.IX Subsection "null"
Null muxer.
.PP
This muxer does not generate any output file, it is mainly useful for
testing or benchmarking purposes.
.PP
For example to benchmark decoding with \fBffmpeg\fR you can use the
command:
.PP
.Vb 1
\&        ffmpeg \-benchmark \-i INPUT \-f null out.null
.Ve
.PP
Note that the above command does not read or write the \fIout.null\fR
file, but specifying the output file is required by the \fBffmpeg\fR
syntax.
.PP
Alternatively you can write the command as:
.PP
.Vb 1
\&        ffmpeg \-benchmark \-i INPUT \-f null \-
.Ve
.SS "nut"
.IX Subsection "nut"
.IP "\fB\-syncpoints\fR \fIflags\fR" 4
.IX Item "-syncpoints flags"
Change the syncpoint usage in nut:
.RS 4
.IP "\fIdefault\fR \fBuse the normal low-overhead seeking aids.\fR" 4
.IX Item "default use the normal low-overhead seeking aids."
.PD 0
.IP "\fInone\fR \fBdo not use the syncpoints at all, reducing the overhead but making the stream non-seekable;\fR" 4
.IX Item "none do not use the syncpoints at all, reducing the overhead but making the stream non-seekable;"
.PD
.Vb 5
\&    Use of this option is not recommended, as the resulting files are very damage
\&    sensitive and seeking is not possible. Also in general the overhead from
\&    syncpoints is negligible. Note, \-C<write_index> 0 can be used to disable
\&    all growing data tables, allowing to mux endless streams with limited memory
\&    and without these disadvantages.
.Ve
.IP "\fItimestamped\fR \fBextend the syncpoint with a wallclock field.\fR" 4
.IX Item "timestamped extend the syncpoint with a wallclock field."
.RE
.RS 4
.Sp
The \fInone\fR and \fItimestamped\fR flags are experimental.
.RE
.IP "\fB\-write_index\fR \fIbool\fR" 4
.IX Item "-write_index bool"
Write index at the end, the default is to write an index.
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f_strict experimental \-syncpoints none \- | processor
.Ve
.SS "ogg"
.IX Subsection "ogg"
Ogg container muxer.
.IP "\fB\-page_duration\fR \fIduration\fR" 4
.IX Item "-page_duration duration"
Preferred page duration, in microseconds. The muxer will attempt to create
pages that are approximately \fIduration\fR microseconds long. This allows the
user to compromise between seek granularity and container overhead. The default
is 1 second. A value of 0 will fill all segments, making pages as large as
possible. A value of 1 will effectively use 1 packet-per-page in most
situations, giving a small seek granularity at the cost of additional container
overhead.
.IP "\fB\-serial_offset\fR \fIvalue\fR" 4
.IX Item "-serial_offset value"
Serial value from which to set the streams serial number.
Setting it to different and sufficiently large values ensures that the produced
ogg files can be safely chained.
.SS "segment, stream_segment, ssegment"
.IX Subsection "segment, stream_segment, ssegment"
Basic stream segmenter.
.PP
This muxer outputs streams to a number of separate files of nearly
fixed duration. Output filename pattern can be set in a fashion
similar to \fBimage2\fR, or by using a \f(CW\*(C`strftime\*(C'\fR template if
the \fBstrftime\fR option is enabled.
.PP
\&\f(CW\*(C`stream_segment\*(C'\fR is a variant of the muxer used to write to
streaming output formats, i.e. which do not require global headers,
and is recommended for outputting e.g. to \s-1MPEG\s0 transport stream segments.
\&\f(CW\*(C`ssegment\*(C'\fR is a shorter alias for \f(CW\*(C`stream_segment\*(C'\fR.
.PP
Every segment starts with a keyframe of the selected reference stream,
which is set through the \fBreference_stream\fR option.
.PP
Note that if you want accurate splitting for a video file, you need to
make the input key frames correspond to the exact splitting times
expected by the segmenter, or the segment muxer will start the new
segment with the key frame found next after the specified start
time.
.PP
The segment muxer works best with a single constant frame rate video.
.PP
Optionally it can generate a list of the created segments, by setting
the option \fIsegment_list\fR. The list type is specified by the
\&\fIsegment_list_type\fR option. The entry filenames in the segment
list are set by default to the basename of the corresponding segment
files.
.PP
See also the \fBhls\fR muxer, which provides a more specific
implementation for \s-1HLS\s0 segmentation.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
The segment muxer supports the following options:
.IP "\fBincrement_tc\fR \fI1|0\fR" 4
.IX Item "increment_tc 1|0"
if set to \f(CW1\fR, increment timecode between each segment
If this is selected, the input need to have
a timecode in the first video stream. Default value is
\&\f(CW0\fR.
.IP "\fBreference_stream\fR \fIspecifier\fR" 4
.IX Item "reference_stream specifier"
Set the reference stream, as specified by the string \fIspecifier\fR.
If \fIspecifier\fR is set to \f(CW\*(C`auto\*(C'\fR, the reference is chosen
automatically. Otherwise it must be a stream specifier (see the ``Stream
specifiers'' chapter in the ffmpeg manual) which specifies the
reference stream. The default value is \f(CW\*(C`auto\*(C'\fR.
.IP "\fBsegment_format\fR \fIformat\fR" 4
.IX Item "segment_format format"
Override the inner container format, by default it is guessed by the filename
extension.
.IP "\fBsegment_format_options\fR \fIoptions_list\fR" 4
.IX Item "segment_format_options options_list"
Set output format options using a :\-separated list of key=value
parameters. Values containing the \f(CW\*(C`:\*(C'\fR special character must be
escaped.
.IP "\fBsegment_list\fR \fIname\fR" 4
.IX Item "segment_list name"
Generate also a listfile named \fIname\fR. If not specified no
listfile is generated.
.IP "\fBsegment_list_flags\fR \fIflags\fR" 4
.IX Item "segment_list_flags flags"
Set flags affecting the segment list generation.
.Sp
It currently supports the following flags:
.RS 4
.IP "\fBcache\fR" 4
.IX Item "cache"
Allow caching (only affects M3U8 list files).
.IP "\fBlive\fR" 4
.IX Item "live"
Allow live-friendly file generation.
.RE
.RS 4
.RE
.IP "\fBsegment_list_size\fR \fIsize\fR" 4
.IX Item "segment_list_size size"
Update the list file so that it contains at most \fIsize\fR
segments. If 0 the list file will contain all the segments. Default
value is 0.
.IP "\fBsegment_list_entry_prefix\fR \fIprefix\fR" 4
.IX Item "segment_list_entry_prefix prefix"
Prepend \fIprefix\fR to each entry. Useful to generate absolute paths.
By default no prefix is applied.
.IP "\fBsegment_list_type\fR \fItype\fR" 4
.IX Item "segment_list_type type"
Select the listing format.
.Sp
The following values are recognized:
.RS 4
.IP "\fBflat\fR" 4
.IX Item "flat"
Generate a flat list for the created segments, one segment per line.
.IP "\fBcsv, ext\fR" 4
.IX Item "csv, ext"
Generate a list for the created segments, one segment per line,
each line matching the format (comma-separated values):
.Sp
.Vb 1
\&        <segment_filename>,<segment_start_time>,<segment_end_time>
.Ve
.Sp
\&\fIsegment_filename\fR is the name of the output file generated by the
muxer according to the provided pattern. \s-1CSV\s0 escaping (according to
\&\s-1RFC4180\s0) is applied if required.
.Sp
\&\fIsegment_start_time\fR and \fIsegment_end_time\fR specify
the segment start and end time expressed in seconds.
.Sp
A list file with the suffix \f(CW".csv"\fR or \f(CW".ext"\fR will
auto-select this format.
.Sp
\&\fBext\fR is deprecated in favor or \fBcsv\fR.
.IP "\fBffconcat\fR" 4
.IX Item "ffconcat"
Generate an ffconcat file for the created segments. The resulting file
can be read using the FFmpeg \fBconcat\fR demuxer.
.Sp
A list file with the suffix \f(CW".ffcat"\fR or \f(CW".ffconcat"\fR will
auto-select this format.
.IP "\fBm3u8\fR" 4
.IX Item "m3u8"
Generate an extended M3U8 file, version 3, compliant with
<\fBhttp://tools.ietf.org/id/draft\-pantos\-http\-live\-streaming\fR>.
.Sp
A list file with the suffix \f(CW".m3u8"\fR will auto-select this format.
.RE
.RS 4
.Sp
If not specified the type is guessed from the list file name suffix.
.RE
.IP "\fBsegment_time\fR \fItime\fR" 4
.IX Item "segment_time time"
Set segment duration to \fItime\fR, the value must be a duration
specification. Default value is \*(L"2\*(R". See also the
\&\fBsegment_times\fR option.
.Sp
Note that splitting may not be accurate, unless you force the
reference stream key-frames at the given time. See the introductory
notice and the examples below.
.IP "\fBsegment_atclocktime\fR \fI1|0\fR" 4
.IX Item "segment_atclocktime 1|0"
If set to \*(L"1\*(R" split at regular clock time intervals starting from 00:00
o'clock. The \fItime\fR value specified in \fBsegment_time\fR is
used for setting the length of the splitting interval.
.Sp
For example with \fBsegment_time\fR set to \*(L"900\*(R" this makes it possible
to create files at 12:00 o'clock, 12:15, 12:30, etc.
.Sp
Default value is \*(L"0\*(R".
.IP "\fBsegment_clocktime_offset\fR \fIduration\fR" 4
.IX Item "segment_clocktime_offset duration"
Delay the segment splitting times with the specified duration when using
\&\fBsegment_atclocktime\fR.
.Sp
For example with \fBsegment_time\fR set to \*(L"900\*(R" and
\&\fBsegment_clocktime_offset\fR set to \*(L"300\*(R" this makes it possible to
create files at 12:05, 12:20, 12:35, etc.
.Sp
Default value is \*(L"0\*(R".
.IP "\fBsegment_clocktime_wrap_duration\fR \fIduration\fR" 4
.IX Item "segment_clocktime_wrap_duration duration"
Force the segmenter to only start a new segment if a packet reaches the muxer
within the specified duration after the segmenting clock time. This way you
can make the segmenter more resilient to backward local time jumps, such as
leap seconds or transition to standard time from daylight savings time.
.Sp
Assuming that the delay between the packets of your source is less than 0.5
second you can detect a leap second by specifying 0.5 as the duration.
.Sp
Default is the maximum possible duration which means starting a new segment
regardless of the elapsed time since the last clock time.
.IP "\fBsegment_time_delta\fR \fIdelta\fR" 4
.IX Item "segment_time_delta delta"
Specify the accuracy time when selecting the start time for a
segment, expressed as a duration specification. Default value is \*(L"0\*(R".
.Sp
When delta is specified a key-frame will start a new segment if its
\&\s-1PTS\s0 satisfies the relation:
.Sp
.Vb 1
\&        PTS >= start_time \- time_delta
.Ve
.Sp
This option is useful when splitting video content, which is always
split at \s-1GOP\s0 boundaries, in case a key frame is found just before the
specified split time.
.Sp
In particular may be used in combination with the \fIffmpeg\fR option
\&\fIforce_key_frames\fR. The key frame times specified by
\&\fIforce_key_frames\fR may not be set accurately because of rounding
issues, with the consequence that a key frame time may result set just
before the specified time. For constant frame rate videos a value of
1/(2*\fIframe_rate\fR) should address the worst case mismatch between
the specified time and the time set by \fIforce_key_frames\fR.
.IP "\fBsegment_times\fR \fItimes\fR" 4
.IX Item "segment_times times"
Specify a list of split points. \fItimes\fR contains a list of comma
separated duration specifications, in increasing order. See also
the \fBsegment_time\fR option.
.IP "\fBsegment_frames\fR \fIframes\fR" 4
.IX Item "segment_frames frames"
Specify a list of split video frame numbers. \fIframes\fR contains a
list of comma separated integer numbers, in increasing order.
.Sp
This option specifies to start a new segment whenever a reference
stream key frame is found and the sequential number (starting from 0)
of the frame is greater or equal to the next value in the list.
.IP "\fBsegment_wrap\fR \fIlimit\fR" 4
.IX Item "segment_wrap limit"
Wrap around segment index once it reaches \fIlimit\fR.
.IP "\fBsegment_start_number\fR \fInumber\fR" 4
.IX Item "segment_start_number number"
Set the sequence number of the first segment. Defaults to \f(CW0\fR.
.IP "\fBstrftime\fR \fI1|0\fR" 4
.IX Item "strftime 1|0"
Use the \f(CW\*(C`strftime\*(C'\fR function to define the name of the new
segments to write. If this is selected, the output segment name must
contain a \f(CW\*(C`strftime\*(C'\fR function template. Default value is
\&\f(CW0\fR.
.IP "\fBbreak_non_keyframes\fR \fI1|0\fR" 4
.IX Item "break_non_keyframes 1|0"
If enabled, allow segments to start on frames other than keyframes. This
improves behavior on some players when the time between keyframes is
inconsistent, but may make things worse on others, and can cause some oddities
during seeking. Defaults to \f(CW0\fR.
.IP "\fBreset_timestamps\fR \fI1|0\fR" 4
.IX Item "reset_timestamps 1|0"
Reset timestamps at the begin of each segment, so that each segment
will start with near-zero timestamps. It is meant to ease the playback
of the generated segments. May not work with some combinations of
muxers/codecs. It is set to \f(CW0\fR by default.
.IP "\fBinitial_offset\fR \fIoffset\fR" 4
.IX Item "initial_offset offset"
Specify timestamp offset to apply to the output packet timestamps. The
argument must be a time duration specification, and defaults to 0.
.IP "\fBwrite_empty_segments\fR \fI1|0\fR" 4
.IX Item "write_empty_segments 1|0"
If enabled, write an empty segment if there are no packets during the period a
segment would usually span. Otherwise, the segment will be filled with the next
packet written. Defaults to \f(CW0\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Remux the content of file \fIin.mkv\fR to a list of segments
\&\fIout\-000.nut\fR, \fIout\-001.nut\fR, etc., and write the list of
generated segments to \fIout.list\fR:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list out.list out%03d.nut
.Ve
.IP "\(bu" 4
Segment input and set output format options for the output segments:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-f segment \-segment_time 10 \-segment_format_options movflags=+faststart out%03d.mp4
.Ve
.IP "\(bu" 4
Segment the input file according to the split points specified by the
\&\fIsegment_times\fR option:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list out.csv \-segment_times 1,2,3,5,8,13,21 out%03d.nut
.Ve
.IP "\(bu" 4
Use the \fBffmpeg\fR \fBforce_key_frames\fR
option to force key frames in the input at the specified location, together
with the segment option \fBsegment_time_delta\fR to account for
possible roundings operated when setting key frame times.
.Sp
.Vb 2
\&        ffmpeg \-i in.mkv \-force_key_frames 1,2,3,5,8,13,21 \-codec:v mpeg4 \-codec:a pcm_s16le \-map 0 \e
\&        \-f segment \-segment_list out.csv \-segment_times 1,2,3,5,8,13,21 \-segment_time_delta 0.05 out%03d.nut
.Ve
.Sp
In order to force key frames on the input file, transcoding is
required.
.IP "\(bu" 4
Segment the input file by splitting the input file according to the
frame numbers sequence specified with the \fBsegment_frames\fR option:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list out.csv \-segment_frames 100,200,300,500,800 out%03d.nut
.Ve
.IP "\(bu" 4
Convert the \fIin.mkv\fR to \s-1TS\s0 segments using the \f(CW\*(C`libx264\*(C'\fR
and \f(CW\*(C`aac\*(C'\fR encoders:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-map 0 \-codec:v libx264 \-codec:a aac \-f ssegment \-segment_list out.list out%03d.ts
.Ve
.IP "\(bu" 4
Segment the input file, and create an M3U8 live playlist (can be used
as live \s-1HLS\s0 source):
.Sp
.Vb 2
\&        ffmpeg \-re \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list playlist.m3u8 \e
\&        \-segment_list_flags +live \-segment_time 10 out%03d.mkv
.Ve
.SS "smoothstreaming"
.IX Subsection "smoothstreaming"
Smooth Streaming muxer generates a set of files (Manifest, chunks) suitable for serving with conventional web server.
.IP "\fBwindow_size\fR" 4
.IX Item "window_size"
Specify the number of fragments kept in the manifest. Default 0 (keep all).
.IP "\fBextra_window_size\fR" 4
.IX Item "extra_window_size"
Specify the number of fragments kept outside of the manifest before removing from disk. Default 5.
.IP "\fBlookahead_count\fR" 4
.IX Item "lookahead_count"
Specify the number of lookahead fragments. Default 2.
.IP "\fBmin_frag_duration\fR" 4
.IX Item "min_frag_duration"
Specify the minimum fragment duration (in microseconds). Default 5000000.
.IP "\fBremove_at_exit\fR" 4
.IX Item "remove_at_exit"
Specify whether to remove all fragments when finished. Default 0 (do not remove).
.SS "fifo"
.IX Subsection "fifo"
The fifo pseudo-muxer allows the separation of encoding and muxing by using
first-in-first-out queue and running the actual muxer in a separate thread. This
is especially useful in combination with the \fBtee\fR muxer and can be used to
send data to several destinations with different reliability/writing speed/latency.
.PP
\&\s-1API\s0 users should be aware that callback functions (interrupt_callback,
io_open and io_close) used within its AVFormatContext must be thread-safe.
.PP
The behavior of the fifo muxer if the queue fills up or if the output fails is
selectable,
.IP "\(bu" 4
output can be transparently restarted with configurable delay between retries
based on real time or time of the processed stream.
.IP "\(bu" 4
encoding can be blocked during temporary failure, or continue transparently
dropping packets in case fifo queue fills up.
.IP "\fBfifo_format\fR" 4
.IX Item "fifo_format"
Specify the format name. Useful if it cannot be guessed from the
output name suffix.
.IP "\fBqueue_size\fR" 4
.IX Item "queue_size"
Specify size of the queue (number of packets). Default value is 60.
.IP "\fBformat_opts\fR" 4
.IX Item "format_opts"
Specify format options for the underlying muxer. Muxer options can be specified
as a list of \fIkey\fR=\fIvalue\fR pairs separated by ':'.
.IP "\fBdrop_pkts_on_overflow\fR \fIbool\fR" 4
.IX Item "drop_pkts_on_overflow bool"
If set to 1 (true), in case the fifo queue fills up, packets will be dropped
rather than blocking the encoder. This makes it possible to continue streaming without
delaying the input, at the cost of omitting part of the stream. By default
this option is set to 0 (false), so in such cases the encoder will be blocked
until the muxer processes some of the packets and none of them is lost.
.IP "\fBattempt_recovery\fR \fIbool\fR" 4
.IX Item "attempt_recovery bool"
If failure occurs, attempt to recover the output. This is especially useful
when used with network output, since it makes it possible to restart streaming transparently.
By default this option is set to 0 (false).
.IP "\fBmax_recovery_attempts\fR" 4
.IX Item "max_recovery_attempts"
Sets maximum number of successive unsuccessful recovery attempts after which
the output fails permanently. By default this option is set to 0 (unlimited).
.IP "\fBrecovery_wait_time\fR \fIduration\fR" 4
.IX Item "recovery_wait_time duration"
Waiting time before the next recovery attempt after previous unsuccessful
recovery attempt. Default value is 5 seconds.
.IP "\fBrecovery_wait_streamtime\fR \fIbool\fR" 4
.IX Item "recovery_wait_streamtime bool"
If set to 0 (false), the real time is used when waiting for the recovery
attempt (i.e. the recovery will be attempted after at least
recovery_wait_time seconds).
If set to 1 (true), the time of the processed stream is taken into account
instead (i.e. the recovery will be attempted after at least \fIrecovery_wait_time\fR
seconds of the stream is omitted).
By default, this option is set to 0 (false).
.IP "\fBrecover_any_error\fR \fIbool\fR" 4
.IX Item "recover_any_error bool"
If set to 1 (true), recovery will be attempted regardless of type of the error
causing the failure. By default this option is set to 0 (false) and in case of
certain (usually permanent) errors the recovery is not attempted even when
\&\fIattempt_recovery\fR is set to 1.
.IP "\fBrestart_with_keyframe\fR \fIbool\fR" 4
.IX Item "restart_with_keyframe bool"
Specify whether to wait for the keyframe after recovering from
queue overflow or failure. This option is set to 0 (false) by default.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Stream something to rtmp server, continue processing the stream at real-time
rate even in case of temporary failure (network outage) and attempt to recover
streaming every second indefinitely.
.Sp
.Vb 2
\&        ffmpeg \-re \-i ... \-c:v libx264 \-c:a aac \-f fifo \-fifo_format flv \-map 0:v \-map 0:a
\&          \-drop_pkts_on_overflow 1 \-attempt_recovery 1 \-recovery_wait_time 1 rtmp://example.com/live/stream_name
.Ve
.SS "tee"
.IX Subsection "tee"
The tee muxer can be used to write the same data to several files or any
other kind of muxer. It can be used, for example, to both stream a video to
the network and save it to disk at the same time.
.PP
It is different from specifying several outputs to the \fBffmpeg\fR
command-line tool because the audio and video data will be encoded only once
with the tee muxer; encoding can be a very expensive process. It is not
useful when using the libavformat \s-1API\s0 directly because it is then possible
to feed the same packets to several muxers directly.
.PP
The slave outputs are specified in the file name given to the muxer,
separated by '|'. If any of the slave name contains the '|' separator,
leading or trailing spaces or any special character, it must be
escaped (see \fBthe \*(L"Quoting and escaping\*(R"
section in the \f(BIffmpeg\-utils\fB\|(1) manual\fR).
.PP
Muxer options can be specified for each slave by prepending them as a list of
\&\fIkey\fR=\fIvalue\fR pairs separated by ':', between square brackets. If
the options values contain a special character or the ':' separator, they
must be escaped; note that this is a second level escaping.
.PP
The following special options are also recognized:
.IP "\fBf\fR" 4
.IX Item "f"
Specify the format name. Useful if it cannot be guessed from the
output name suffix.
.IP "\fBbsfs[/\fR\fIspec\fR\fB]\fR" 4
.IX Item "bsfs[/spec]"
Specify a list of bitstream filters to apply to the specified
output.
.Sp
It is possible to specify to which streams a given bitstream filter
applies, by appending a stream specifier to the option separated by
\&\f(CW\*(C`/\*(C'\fR. \fIspec\fR must be a stream specifier (see \fBFormat
stream specifiers\fR).  If the stream specifier is not specified, the
bitstream filters will be applied to all streams in the output.
.Sp
Several bitstream filters can be specified, separated by \*(L",\*(R".
.IP "\fBselect\fR" 4
.IX Item "select"
Select the streams that should be mapped to the slave output,
specified by a stream specifier. If not specified, this defaults to
all the input streams. You may use multiple stream specifiers
separated by commas (\f(CW\*(C`,\*(C'\fR) e.g.: \f(CW\*(C`a:0,v\*(C'\fR
.IP "\fBonfail\fR" 4
.IX Item "onfail"
Specify behaviour on output failure. This can be set to either \f(CW\*(C`abort\*(C'\fR (which is
default) or \f(CW\*(C`ignore\*(C'\fR. \f(CW\*(C`abort\*(C'\fR will cause whole process to fail in case of failure
on this slave output. \f(CW\*(C`ignore\*(C'\fR will ignore failure on this output, so other outputs
will continue without being affected.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Encode something and both archive it in a WebM file and stream it
as MPEG-TS over \s-1UDP \s0(the streams need to be explicitly mapped):
.Sp
.Vb 2
\&        ffmpeg \-i ... \-c:v libx264 \-c:a mp2 \-f tee \-map 0:v \-map 0:a
\&          "archive\-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/"
.Ve
.IP "\(bu" 4
As above, but continue streaming even if output to local file fails
(for example local drive fills up):
.Sp
.Vb 2
\&        ffmpeg \-i ... \-c:v libx264 \-c:a mp2 \-f tee \-map 0:v \-map 0:a
\&          "[onfail=ignore]archive\-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/"
.Ve
.IP "\(bu" 4
Use \fBffmpeg\fR to encode the input, and send the output
to three different destinations. The \f(CW\*(C`dump_extra\*(C'\fR bitstream
filter is used to add extradata information to all the output video
keyframes packets, as requested by the MPEG-TS format. The select
option is applied to \fIout.aac\fR in order to make it contain only
audio packets.
.Sp
.Vb 2
\&        ffmpeg \-i ... \-map 0 \-flags +global_header \-c:v libx264 \-c:a aac \-strict experimental
\&               \-f tee "[bsfs/v=dump_extra]out.ts|[movflags=+faststart]out.mp4|[select=a]out.aac"
.Ve
.IP "\(bu" 4
As below, but select only stream \f(CW\*(C`a:1\*(C'\fR for the audio output. Note
that a second level escaping must be performed, as \*(L":\*(R" is a special
character used to separate options.
.Sp
.Vb 2
\&        ffmpeg \-i ... \-map 0 \-flags +global_header \-c:v libx264 \-c:a aac \-strict experimental
\&               \-f tee "[bsfs/v=dump_extra]out.ts|[movflags=+faststart]out.mp4|[select=\e\*(Aqa:1\e\*(Aq]out.aac"
.Ve
.PP
Note: some codecs may need different options depending on the output format;
the auto-detection of this can not work with the tee muxer. The main example
is the \fBglobal_header\fR flag.
.SS "webm_dash_manifest"
.IX Subsection "webm_dash_manifest"
WebM \s-1DASH\s0 Manifest muxer.
.PP
This muxer implements the WebM \s-1DASH\s0 Manifest specification to generate the \s-1DASH\s0
manifest \s-1XML.\s0 It also supports manifest generation for \s-1DASH\s0 live streams.
.PP
For more information see:
.IP "\(bu" 4
WebM \s-1DASH\s0 Specification: <\fBhttps://sites.google.com/a/webmproject.org/wiki/adaptive\-streaming/webm\-dash\-specification\fR>
.IP "\(bu" 4
\&\s-1ISO DASH\s0 Specification: <\fBhttp://standards.iso.org/ittf/PubliclyAvailableStandards/c065274_ISO_IEC_23009\-1_2014.zip\fR>
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
This muxer supports the following options:
.IP "\fBadaptation_sets\fR" 4
.IX Item "adaptation_sets"
This option has the following syntax: \*(L"id=x,streams=a,b,c id=y,streams=d,e\*(R" where x and y are the
unique identifiers of the adaptation sets and a,b,c,d and e are the indices of the corresponding
audio and video streams. Any number of adaptation sets can be added using this option.
.IP "\fBlive\fR" 4
.IX Item "live"
Set this to 1 to create a live stream \s-1DASH\s0 Manifest. Default: 0.
.IP "\fBchunk_start_index\fR" 4
.IX Item "chunk_start_index"
Start index of the first chunk. This will go in the \fBstartNumber\fR attribute
of the \fBSegmentTemplate\fR element in the manifest. Default: 0.
.IP "\fBchunk_duration_ms\fR" 4
.IX Item "chunk_duration_ms"
Duration of each chunk in milliseconds. This will go in the \fBduration\fR
attribute of the \fBSegmentTemplate\fR element in the manifest. Default: 1000.
.IP "\fButc_timing_url\fR" 4
.IX Item "utc_timing_url"
\&\s-1URL\s0 of the page that will return the \s-1UTC\s0 timestamp in \s-1ISO\s0 format. This will go
in the \fBvalue\fR attribute of the \fBUTCTiming\fR element in the manifest.
Default: None.
.IP "\fBtime_shift_buffer_depth\fR" 4
.IX Item "time_shift_buffer_depth"
Smallest time (in seconds) shifting buffer for which any Representation is
guaranteed to be available. This will go in the \fBtimeShiftBufferDepth\fR
attribute of the \fB\s-1MPD\s0\fR element. Default: 60.
.IP "\fBminimum_update_period\fR" 4
.IX Item "minimum_update_period"
Minimum update period (in seconds) of the manifest. This will go in the
\&\fBminimumUpdatePeriod\fR attribute of the \fB\s-1MPD\s0\fR element. Default: 0.
.PP
\fIExample\fR
.IX Subsection "Example"
.PP
.Vb 9
\&        ffmpeg \-f webm_dash_manifest \-i video1.webm \e
\&               \-f webm_dash_manifest \-i video2.webm \e
\&               \-f webm_dash_manifest \-i audio1.webm \e
\&               \-f webm_dash_manifest \-i audio2.webm \e
\&               \-map 0 \-map 1 \-map 2 \-map 3 \e
\&               \-c copy \e
\&               \-f webm_dash_manifest \e
\&               \-adaptation_sets "id=0,streams=0,1 id=1,streams=2,3" \e
\&               manifest.xml
.Ve
.SS "webm_chunk"
.IX Subsection "webm_chunk"
WebM Live Chunk Muxer.
.PP
This muxer writes out WebM headers and chunks as separate files which can be
consumed by clients that support WebM Live streams via \s-1DASH.\s0
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
This muxer supports the following options:
.IP "\fBchunk_start_index\fR" 4
.IX Item "chunk_start_index"
Index of the first chunk (defaults to 0).
.IP "\fBheader\fR" 4
.IX Item "header"
Filename of the header where the initialization data will be written.
.IP "\fBaudio_chunk_duration\fR" 4
.IX Item "audio_chunk_duration"
Duration of each audio chunk in milliseconds (defaults to 5000).
.PP
\fIExample\fR
.IX Subsection "Example"
.PP
.Vb 10
\&        ffmpeg \-f v4l2 \-i /dev/video0 \e
\&               \-f alsa \-i hw:0 \e
\&               \-map 0:0 \e
\&               \-c:v libvpx\-vp9 \e
\&               \-s 640x360 \-keyint_min 30 \-g 30 \e
\&               \-f webm_chunk \e
\&               \-header webm_live_video_360.hdr \e
\&               \-chunk_start_index 1 \e
\&               webm_live_video_360_%d.chk \e
\&               \-map 1:0 \e
\&               \-c:a libvorbis \e
\&               \-b:a 128k \e
\&               \-f webm_chunk \e
\&               \-header webm_live_audio_128.hdr \e
\&               \-chunk_start_index 1 \e
\&               \-audio_chunk_duration 1000 \e
\&               webm_live_audio_128_%d.chk
.Ve
.SH "METADATA"
.IX Header "METADATA"
FFmpeg is able to dump metadata from media files into a simple UTF\-8\-encoded
INI-like text file and then load it back using the metadata muxer/demuxer.
.PP
The file format is as follows:
.IP "1." 4
A file consists of a header and a number of metadata tags divided into sections,
each on its own line.
.IP "2." 4
The header is a \fB;FFMETADATA\fR string, followed by a version number (now 1).
.IP "3." 4
Metadata tags are of the form \fBkey=value\fR
.IP "4." 4
Immediately after header follows global metadata
.IP "5." 4
After global metadata there may be sections with per\-stream/per\-chapter
metadata.
.IP "6." 4
A section starts with the section name in uppercase (i.e. \s-1STREAM\s0 or \s-1CHAPTER\s0) in
brackets (\fB[\fR, \fB]\fR) and ends with next section or end of file.
.IP "7." 4
At the beginning of a chapter section there may be an optional timebase to be
used for start/end values. It must be in form
\&\fBTIMEBASE=\fR\fInum\fR\fB/\fR\fIden\fR, where \fInum\fR and \fIden\fR are
integers. If the timebase is missing then start/end times are assumed to
be in milliseconds.
.Sp
Next a chapter section must contain chapter start and end times in form
\&\fBSTART=\fR\fInum\fR, \fBEND=\fR\fInum\fR, where \fInum\fR is a positive
integer.
.IP "8." 4
Empty lines and lines starting with \fB;\fR or \fB#\fR are ignored.
.IP "9." 4
Metadata keys or values containing special characters (\fB=\fR, \fB;\fR,
\&\fB#\fR, \fB\e\fR and a newline) must be escaped with a backslash \fB\e\fR.
.IP "10." 4
Note that whitespace in metadata (e.g. \fBfoo = bar\fR) is considered to be
a part of the tag (in the example above key is \fBfoo\fR , value is
 \fBbar\fR).
.PP
A ffmetadata file might look like this:
.PP
.Vb 4
\&        ;FFMETADATA1
\&        title=bike\e\eshed
\&        ;this is a comment
\&        artist=FFmpeg troll team
\&        
\&        [CHAPTER]
\&        TIMEBASE=1/1000
\&        START=0
\&        #chapter ends at 0:01:00
\&        END=60000
\&        title=chapter \e#1
\&        [STREAM]
\&        title=multi\e
\&        line
.Ve
.PP
By using the ffmetadata muxer and demuxer it is possible to extract
metadata from an input file to an ffmetadata file, and then transcode
the file into an output file with the edited ffmetadata file.
.PP
Extracting an ffmetadata file with \fIffmpeg\fR goes as follows:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f ffmetadata FFMETADATAFILE
.Ve
.PP
Reinserting edited metadata information from the \s-1FFMETADATAFILE\s0 file can
be done as:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-i FFMETADATAFILE \-map_metadata 1 \-codec copy OUTPUT
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIffmpeg\fR\|(1), \fIffplay\fR\|(1), \fIffprobe\fR\|(1), \fIffserver\fR\|(1), \fIlibavformat\fR\|(3)
.SH "AUTHORS"
.IX Header "AUTHORS"
The FFmpeg developers.
.PP
For details about the authorship, see the Git history of the project
(git://source.ffmpeg.org/ffmpeg), e.g. by typing the command
\&\fBgit log\fR in the FFmpeg source directory, or browsing the
online repository at <\fBhttp://source.ffmpeg.org\fR>.
.PP
Maintainers for the specific components are listed in the file
\&\fI\s-1MAINTAINERS\s0\fR in the source code tree.
